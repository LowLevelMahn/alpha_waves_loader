IFNDEF __WASM__
  IFNDEF __UASM__
    IS_MASM = 1
  ENDIF
ENDIF

IFNDEF __WASM__

  %OUT ====================================
  ; keep resulting ae_org.com file 100% binary equal to ALPHA_E.COM in non DIRECT_START/CLEANUP build
  IFDEF BINARY_EQUAL
    %OUT BINARY_EQUAL set
  ELSE
    %OUT BINARY_EQUAL not set
  ENDIF
  
  IFDEF DIRECT_START
    %OUT DIRECT_START set
  ELSE
    %OUT DIRECT_START not set
  ENDIF

  IFDEF CLEANUP
    %OUT CLEANUP unused data/code
  ELSE
    %OUT CLEANUP not set  
  ENDIF

  %OUT ====================================

ENDIF

IFDEF BINARY_EQUAL
  IFDEF __WASM__
    WASM_BINARY_EQUAL = 1
  ENDIF
ENDIF  

NOOP = 90h
EMPTY = 0AAh

; ---------------------------------------------------------------------------

ptr16		struc ;	(sizeof=0x4)	; XREF:	seg000:maybe_exe_bufferr
					; seg000:some_game_ptrr ...
ofs		dw ?
segm		dw ?
ptr16   ends

; ---------------------------------------------------------------------------

gfx_block_t	struc ;	(sizeof=0x18)
filename	db 18 dup(?)		; XREF:	start_0+30Ao start_0+324o ...
byte_12h	db ?			; XREF:	read_some_file_sub_4+54r
byte_13h	db ?			; XREF:	GAME_START_sub_7+1Dr
					; start_0+2FBr	...
byte_14h	db ?			; XREF:	START_GAME_IS_GFX_SUPPORTED_sub_12+5r
byte_15h	db ?
word_16h	dw ?			; XREF:	START_GAME_FEATURE_FLAG_STUFF_sub_21r
gfx_block_t	ends
; ---------------------------------------------------------------------------
CommandTail	struc ;	(sizeof=0x80)	; XREF:	sPSPr
count		db ?
buffer		db 127 dup(?)
CommandTail	ends
; ---------------------------------------------------------------------------
; Program segment prefix from dosbox source
sPSP		struc ;	(sizeof=0x100)
exit_code		db 2 dup(?)		; XREF:	EXE_HEADER_sub_2+140o
					; GAME_START_sub_6+13o
next_seg	dw ?
fill_1		db ?
far_call	db ?
cpm_entry	ptr16 <?>
int_22		ptr16 <?>
int_23		ptr16 <?>
int_24		ptr16 <?>
psp_parent	dw ?
files		db 20 dup(?)
environment	dw ?
stack		dd ?
max_files	dw ?
file_table	ptr16 <?>
prev_psp	ptr16 <?>
interim_flag	db ?
truename_flag	db ?
nn_flags	dw ?
version_dos	dw ?
fill_2		db 14 dup(?)
service		db 3 dup(?)
fill_3		db 9 dup(?)
fcb1		db 16 dup(?)
fcb2		db 16 dup(?)
fill_4		db 4 dup(?)
cmdtail_or_dta	CommandTail <?>		; XREF:	GAME_START_sub_6+2Eo ;	or DTA
sPSP		ends
; ---------------------------------------------------------------------------
; exe header from dosbox source
EXE_Header	struc ;	(sizeof=0x1C)
signature	dw ?			; XREF:	EXE_HEADER_sub_2:loc_560r
extrabytes	dw ?
pages		dw ?
relocations	dw ?
headersize	dw ?			; XREF:	EXE_HEADER_sub_2:loc_562r
minmemory	dw ?
maxmemory	dw ?
initSS		dw ?			; XREF:	EXE_HEADER_sub_2+E7r
initSP		dw ?			; XREF:	EXE_HEADER_sub_2+DFr
checksum	dw ?
initIP		dw ?			; XREF:	EXE_HEADER_sub_2+FBr
initCS		dw ?			; XREF:	EXE_HEADER_sub_2+F1r
reloctable	dw ?
overlay		dw ?
EXE_Header	ends


;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input MD5   : 7E165FC5FD1AEC1482BC915AB4053D36
; Input CRC32 : E357F62E

; File Name   : D:\projects\fun\dos_games_rev\002297_alpha_waves\disk1\ALPHA_E.COM
; Format      : MS-DOS COM-file
; Base Address: 1000h Range: 10100h-11BC0h Loaded length: 1AC0h

    .286
    .model tiny

; ===========================================================================

; Segment type: Pure code
seg000    segment byte public 'CODE'
    assume cs:seg000
    org 100h
    assume es:nothing, ss:nothing, ds:seg000

; =============== S U B R O U T I N E =======================================

; Attributes: noreturn thunk

    public start
start   proc near
    jmp start_0
start   endp



; ---------------------------------------------------------------------------
IFNDEF CLEANUP

IFDEF DIRECT_START    
    db 3eh dup(EMPTY)
ELSE    
CGA_string	db 'CGA'                ; DATA XREF: seg000:gfx_string_offset_tableo
		db 5 dup(1)		; 0
EGA_string	db 'EGA'                ; DATA XREF: seg000:gfx_string_offset_tableo
		db 5 dup(1)		; 0
TANDY_string	db 'TANDY'              ; DATA XREF: seg000:gfx_string_offset_tableo
		db 5 dup(1)		; 0
HERCULES_string	db  'HERCULES'		; DATA XREF: seg000:gfx_string_offset_tableo
VGA_string	db 'VGA'                ; DATA XREF: seg000:gfx_string_offset_tableo
		db 5 dup(1)		; 0
gfx_string_offset_table	dw offset CGA_string, offset EGA_string, offset	TANDY_string; 0
					; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+3Br
		dw offset HERCULES_string, offset VGA_string; 3	; "CGA"
gfx_type_array	db 2, 3, 40h, 80h, 5	; 0 ; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+Er
gfx_type_array2	db 2, 3, 2, 1, 5	; 0 ; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+2Cr
ENDIF

ENDIF

someway_cs_registe_value1 dw 0		; DATA XREF: GAME_START_sub_7+79w
					; GAME_START_sub_7+8Do
    db 80h, 0
someway_cs_registe_value2 dw 0		; DATA XREF: GAME_START_sub_7+7Ew
    db 5Ch, 0
someway_cs_registe_value3 dw 0		; DATA XREF: GAME_START_sub_7+83w
    db 6Ch, 0
someway_cs_registe_value4 dw 0		; DATA XREF: GAME_START_sub_7+88w
maybe_exe_buffer ptr16 <0>		; DATA XREF: read_some_file_sub_4+20r
          ; read_some_file_sub_4+3Er ...
					;
					;
					;
					; --------------
					;
					; the_overwrite_buffer_begin
					; [config.tat]
					; [maybe_exe_buffer]
					;
					;
					;
					; --------------
some_game_ptr	ptr16 <0>		; DATA XREF: read_some_file_sub_4+D7w
          ; read_some_file_sub_4+1B5r ...
word_44   dw 0      ; DATA XREF: read_some_file_sub_4+25w
          ; read_some_file_sub_4+C2w ...
word_45   dw 0      ; DATA XREF: read_some_file_sub_4+2Cw
          ; read_some_file_sub_4+C7w ...
far_ptr3	ptr16 <0>		; DATA XREF: GAME_START_sub_5+4Br
					; GAME_START_sub_6+3w ...
another_far_ptr	ptr16 <0>		; DATA XREF: read_some_file_sub_4:loc_580w
          ; read_some_file_sub_4+145r ...
somway_exe_buffer_seg dw 0		; DATA XREF: GAME_START_sub_5+Dr
					; GAME_START_sub_5+63r	...
some_register_ss_value dw 0		; DATA XREF: GAME_START_sub_7+96w
					; GAME_START_sub_7+A9r
some_register_sp_value dw 0		; DATA XREF: GAME_START_sub_7+91w
					; GAME_START_sub_7+A4r
maybe_10_ptr	ptr16 0Ah dup(<0>)	; DATA XREF: GAME_START_sub_6+5Do
					; start_0+35o ...
					; ----
					;
					; https://wiki.osdev.org/MZ is sizeof 28h
					;
					;
					; seems	do be always 0???
					;
					;
					; ----
also_a_pointer	ptr16 <0>		; DATA XREF: read_some_file_sub_4+137w
          ; read_some_file_sub_4:loc_584w ...
byte_55		db 0			; DATA XREF: EXE_HEADER_sub_2+1r
					; EXE_HEADER_sub_2+5Cr	...

IFNDEF CLEANUP

IFDEF DIRECT_START
  db EMPTY
ELSE  
byte_56		db 0			; DATA XREF: JOYSTICK_STUFF2_sub_30+7w
					; CALIBRATE_JOYSTICK_STUFF_sub_31+Cr ...
ENDIF
ENDIF
         
byte_57		db 0			; DATA XREF: GAME_START_sub_3+42o
					; GAME_START_sub_3+7Cr	...
byte_569	db 0			; DATA XREF: GAME_START_sub_3:loc_577r
word_60		dw 0			; DATA XREF: GAME_START_sub_3+76r
					; GAME_START_sub_3+EDr	...
    db 4 dup(0)
another_pointer2 ptr16 <0>		; DATA XREF: GAME_START_sub_3+49r
					; GAME_START_sub_3+61w	...
word_62		dw 0			; DATA XREF: EXE_HEADER_sub_2+17w
					; EXE_HEADER_sub_2+9Ar	...
some_game_pointer_seg dw 0		; DATA XREF: EXE_HEADER_sub_2+1Cw
					; EXE_HEADER_sub_2+95r	...
new_psp_seg	dw 0			; DATA XREF: EXE_HEADER_sub_2+2Dr
					; EXE_HEADER_sub_2+103r ...
word_558	dw 0			; DATA XREF: EXE_HEADER_sub_2:loc_557w
some_register_cs_value dw 0		; DATA XREF: EXE_HEADER_sub_2+12w
register_sp_value dw 0			; DATA XREF: EXE_HEADER_sub_2+E3w
					; EXE_HEADER_sub_2+10Br
register_ss_value dw 0			; DATA XREF: EXE_HEADER_sub_2+EDw
					; EXE_HEADER_sub_2+10Fr
exe_cs_ip_ptr	ptr16 <0>		; DATA XREF: EXE_HEADER_sub_2+FFw
					; EXE_HEADER_sub_2+129r ...
; __int16 exe_pointer
exe_pointer	ptr16 <0>		; DATA XREF: EXE_HEADER_sub_2+21w
					; EXE_HEADER_sub_2+57r	...
pointer3	ptr16 <0>		; DATA XREF: EXE_HEADER_sub_2+4Dw
					; EXE_HEADER_sub_2+85r	...
start_psp dw 0      ; DATA XREF: start_0+11w start_0+8Fr
saved_int1_ptr	ptr16 <0>		; DATA XREF: EXE_HEADER_sub_2+3Br
					; start_0+9Er ...
saved_5_interrupt_pointers ptr16 5 dup(<0>) ; DATA XREF: start_0+B9o
          ; INIT_PART_init_stuff_sub_26+4Ao
    
IFNDEF CLEANUP
IFDEF DIRECT_START
   db 6 dup(EMPTY)
ELSE
main_menu_jump_table dw offset start_game ; DATA XREF: start_0+82r
    dw offset select_gfx
    dw offset shutdown_cleanup
ENDIF    
ENDIF
    
config_tat_gfx_table_offset dw 0	; DATA XREF: GFX_SELECT_MENU_sub_9+27r
          ; read_config_and_resize_memory+4Aw ...
					; -------------------------------------------
					;
					;
					;
					; its a	pointer	to a uint16_t[5] table of offsets
          ;
          ; uint16_t* gfx_related_table
					;
					;
					; contains (i think) the code offsets for each grafic card type	in the progs.cc
					;
					;
					;
					;
					;
					; -------------------------------------------
config_tat_game_name_string dw 0	; DATA XREF: MAIN_MENU_sub_8+1Cr
          ; MAIN_MENU_sub_8+35r ...
config_tat_publisher_string dw 0	; DATA XREF: read_config_and_resize_memory+64w
					; START_GAME_DOES_FILE_EXIST_sub_19+6Dr
config_tat_content_end dw 0		; DATA XREF: read_config_and_resize_memory+7Ew
config_tat_filename db 'Config.tat',0   ; DATA XREF: read_config_and_resize_memory+5o
config_tat_disk_name_string dw 0	; DATA XREF: read_config_and_resize_memory+71w
          ; SOME_PRINTING_TWO_sub_17+1Cr
config_tat_size	dw 0			; DATA XREF: read_config_and_resize_memory:loc_817w

some_feature_flags dw 1			; DATA XREF: read_config_and_resize_memory+BCr
					; read_config_and_resize_memory+C5w ...
					;
					;
					;
					; --------------------------
					; bit[	0] = ??? [active on startup]
					; bit[ 1]
					; bit[ 2]
					; bit[ 3]
					; bit[ 4]
					; bit[ 5]
					; bit[ 6]
					; bit[ 7]
					; bit[ 8]
					; bit[ 9]
					; bit[10]
					; bit[11]
					; bit[12] = joystick detected
					; bit[ 13] = currency =	franc
					; bit[14+15]  =	mem size type?
					;	     = 00 = 0 (< 0x4000	free paragraphs)
					;	     = 01 = 1 (>= 0x4000 free paragraphs)
					;	     = 10 = 2 (>= 0x6000 free paragraphs)
					;	     = 11 = 3 (>= 0x8000 free paragraphs)
					; -------------------------
          
IFNDEF CLEANUP          
IFDEF DIRECT_START

   db 4 dup(EMPTY)

ELSE
          
text_video_seg	dw 0B800h		; DATA XREF: SOME_PRINTING_TWO_sub_17+4r

          ; SOME_PRINTING_sub_18+Dr ...
text_x_offset db 0      ; DATA XREF: MAIN_MENU_sub_8+Bw
          ; GFX_SELECT_MENU_sub_9+Bw ...
text_y_offset db 0      ; DATA XREF: MAIN_MENU_sub_8+5w
          ; GFX_SELECT_MENU_sub_9+5w ...

ENDIF
ENDIF

subprogram_exit_code db	0		; DATA XREF: GAME_START_sub_7+B3w
					; start_0+32Fr
dos_version db 0      ; DATA XREF: start_0+1Aw
          ; interrupt_0x24r
          
IFNDEF CLEANUP          
IFDEF DIRECT_START
  db 5 dup(EMPTY)
ELSE
          
grafic_type_supported_table db 5 dup(0)	; DATA XREF: GFX_SELECT_MENU_sub_9+18o
          ; GFX_SELECT_MENU_sub_9+23o ...
					; ----------------------------
					;
					;
					;
					; 5 bytes for the 5 gfx	cards in the gfx select	menu
					;
					; gets filled first with 0xFF (not supported)
					; and then with	the corresponding grafic type nr
					; only for checking if the pressed F-Key in SELEC_GFX_MENU
					; is valid
					;
					;
					;
					;
					;
					; ---------------------------
ENDIF   
ENDIF       
       
IFNDEF CLEANUP       
IFDEF DIRECT_START
  db 4 dup(EMPTY)
ELSE
  word_752	dw 0,0		; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+1r
					; START_GAME_IS_GFX_SUPPORTED_sub_12:loc_92r ...
					; [0] =	active display
					; [1] =	alternate display
ENDIF         
ENDIF 

IFNDEF CLEANUP
IFDEF DIRECT_START
  db EMPTY
ELSE          
current_dos_drive db 0			; DATA XREF: START_GAME_DOES_FILE_EXIST_sub_19+14w
					; START_GAME_DOES_FILE_EXIST_sub_19+5Ar
ENDIF
ENDIF

saved_video_mode db 0			; DATA XREF: start_0+89r

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 177h dup(EMPTY)
ELSE

          ; INIT_PART_init_stuff_sub_26+5w
; __int16 text_not_enough_memory
text_not_enough_memory db 2 dup(0Dh), 3, 10h, 4, 87h, 50h, 72h,	6Fh, 62h, 6Ch
					; DATA XREF: START_GAME_FEATURE_FLAG_STUFF_sub_21-21o
    db 65h, 6Dh, 5, 2 dup(0Dh), 4 dup(20h), 53h, 6Fh, 2 dup(72h)
    db 79h, 2Ch, 6Eh, 6Fh, 74h, 20h, 65h, 6Eh, 6Fh, 75h, 67h
    db 68h, 20h, 6Dh, 65h, 6Dh, 6Fh, 72h, 79h, 24h, 0C9h, 16h dup(0CDh)
    db 0BBh, 0Dh, 0BAh, 4 dup(20h), 4, 87h, 4Ch, 6Fh, 61h
    db 64h, 69h, 6Eh, 67h, 20h, 6 dup(2Eh), 5, 4 dup(20h)
    db 0BAh, 0Dh, 0C8h, 16h dup(0CDh), 0BCh, 24h
; __int16 program_load_problem_msg_info
program_load_problem_msg_info db 2 dup(0Dh), 3, 10h, 4, 87h
					; DATA XREF: read_config_and_resize_memory:loc_816o
					; start_0:some_loading_msg_some_PPI_action_and_back_to_main_menuo
aProblem  db 'Problem'
    db 5, 2 dup(0Dh), 54h, 68h, 65h, 72h, 65h, 20h, 69h, 73h
    db 20h, 61h, 20h, 70h, 72h, 6Fh, 62h, 6Ch, 65h, 6Dh, 20h
    db 77h, 69h, 74h, 68h, 20h, 6Ch, 6Fh, 61h, 64h, 69h, 6Eh
    db 67h, 20h, 74h, 68h, 65h, 0Dh, 70h, 72h, 6Fh, 67h, 72h
    db 61h, 6Dh, 2Eh, 20h, 4Dh, 61h, 6Bh, 65h, 20h, 73h, 75h
    db 72h, 65h, 20h, 74h, 68h, 61h, 74h, 20h, 74h, 68h, 65h
    db 20h, 70h, 72h, 6Fh, 70h, 65h, 72h, 0Dh, 64h, 69h, 73h
    db 6Bh, 20h, 69h, 73h, 20h, 69h, 6Eh, 20h, 74h, 68h, 65h
    db 20h, 64h, 72h, 69h, 76h, 65h, 2Eh, 24h
; __int16 text_problem
text_problem	db 2 dup(0Dh), 3, 10h, 4, 87h, 50h, 72h, 6Fh, 62h, 6Ch
					; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+72o
    db 65h, 6Dh, 5, 2 dup(0Dh), 59h, 6Fh, 75h, 20h
text_problem4	db 64h,	6Fh, 20h, 6Eh, 6Fh, 74h, 20h, 68h, 61h,	76h, 65h
    db 0Dh, 61h
text_problem3	db 6Eh			; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12:loc_624w
    db 20h
text_gfx_not_supported db 8 dup(53h), 20h, 63h,	61h, 72h, 64h, 20h, 69h, 6Eh
					; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+58o
    db 73h, 74h, 61h, 2 dup(6Ch), 65h, 64h, 0Dh, 6Fh, 72h
    db 20h, 79h, 6Fh, 75h, 72h, 20h, 6Dh, 6Fh, 6Eh, 69h, 74h
    db 6Fh, 72h, 20h, 0Dh, 64h, 6Fh, 65h, 73h, 20h, 6Eh, 6Fh
    db 74h, 20h, 73h, 75h, 2 dup(70h), 6Fh, 72h, 74h, 20h
text_esc_or_space_message db 8 dup(53h), 2Eh, 0Dh, 50h,	72h, 65h, 2 dup(73h), 20h
					; DATA XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+60o
    db 45h, 53h, 43h, 20h, 74h, 6Fh, 20h, 63h, 61h, 6Eh, 63h
    db 65h, 6Ch, 2Ch, 20h, 53h, 50h, 41h, 43h, 45h, 20h, 74h
    db 6Fh, 20h, 63h, 6Fh, 6Eh, 74h, 69h, 6Eh, 75h, 65h, 2Eh
    db 2 dup(24h)
    
ENDIF    
ENDIF
   
IFNDEF CLEANUP   
IFDEF DIRECT_START
  db 0EEh dup(EMPTY)
ELSE    
    
; __int16 text_main_menu2
text_main_menu2  db 0Dh, 20h, 0C9h, 0CDh, 2, 23h, 0BBh, 20h, 0Dh, 20h, 0BAh
          ; DATA XREF: MAIN_MENU_sub_8+44o
text_main_menu	db 0Dh dup(20h), 48h, 4Fh, 53h,	54h, 41h, 47h, 45h, 10h	dup(20h)
          ; DATA XREF: MAIN_MENU_sub_8+11o
    db 0BAh, 20h, 0Dh, 20h, 0CCh, 0CDh, 2, 23h, 0B9h, 20h
    db 0Dh, 20h, 0BAh, 20h, 2, 23h, 0BAh, 20h, 0Dh, 20h, 0BAh
    db 0Ch dup(20h), 4Dh, 61h, 69h, 6Eh, 20h, 4Dh, 65h, 6Eh
    db 75h, 0Fh dup(20h), 0BAh, 20h, 0Dh, 20h, 0BAh, 20h, 2
    db 23h, 0BAh, 20h, 0Dh, 20h, 0BAh, 2 dup(20h), 46h, 31h
    db 3 dup(20h), 47h, 61h, 6Dh, 65h, 19h dup(20h), 0BAh
    db 20h, 0Dh, 20h, 0BAh, 2 dup(20h), 46h, 32h, 3 dup(20h)
    db 53h, 65h, 6Ch, 65h, 63h, 74h, 20h, 76h, 69h, 64h, 65h
    db 6Fh, 20h, 63h, 61h, 72h, 64h, 0Ch dup(20h), 0BAh, 20h
    db 0Dh, 20h, 0BAh, 2 dup(20h), 46h, 33h, 3 dup(20h), 52h
    db 65h, 74h, 75h, 72h, 6Eh, 20h, 74h, 6Fh, 20h, 44h, 4Fh
    db 53h, 10h dup(20h), 0BAh, 20h, 0Dh
    
ENDIF    
ENDIF
    
IFNDEF CLEANUP      
IFDEF DIRECT_START
    db 63h dup(EMPTY)
ELSE        
    
; __int16 press_a_function_key_text
press_a_function_key_text db 20h, 0BAh, 20h, 2, 23h, 0BAh, 20h, 0Dh, 20h, 0C8h, 0CDh
          ; DATA XREF: GFX_SELECT_MENU_sub_9+66o
    db 2, 23h, 0BCh, 20h, 3 dup(0Dh), 3, 8, 0C9h, 16h dup(0CDh)
    db 0BBh, 0Dh, 3, 8, 0BAh, 20h, 50h, 72h, 65h, 2 dup(73h)
    db 20h, 61h, 20h, 46h, 75h, 6Eh, 63h, 74h, 69h, 6Fh, 6Eh
    db 20h, 4Bh, 65h, 79h, 20h, 0BAh, 0Dh, 3, 8, 0C8h, 16h dup(0CDh)
    db 0BCh, 24h
    
ENDIF    
ENDIF
    
IFNDEF CLEANUP      
IFDEF DIRECT_START
    db 42h dup(EMPTY)
ELSE    
   
; __int16 select_video_card_text
select_video_card_text db 0Dh, 20h, 0C9h, 0CDh, 2, 23h, 0BBh, 20h, 0Dh, 20h, 0BAh
          ; DATA XREF: GFX_SELECT_MENU_sub_9+11o
    db 8 dup(20h), 53h, 65h, 6Ch, 65h, 63h, 74h, 20h, 56h
    db 69h, 64h, 65h, 6Fh, 20h, 43h, 61h, 72h, 64h, 0Bh dup(20h)
    db 0BAh, 20h, 0Dh, 20h, 0CCh, 0CDh, 2, 23h, 0B9h, 20h
    db 0Dh, 20h, 0BAh, 20h, 2, 23h, 0BAh, 20h, 24h
    
ENDIF
ENDIF

IFNDEF CLEANUP      
IFDEF DIRECT_START    
  db 4dh dup(EMPTY)
ELSE
    
; __int16 byte_631
byte_631  db 0Dh, 20h, 0C9h, 0CDh, 2, 2Ah, 0BBh, 20h, 0Dh, 20h, 0BAh
          ; DATA XREF: SOME_PRINTING_THREE_sub_14+17o
    db 20h, 2, 2Ah, 0BAh, 20h, 0Dh, 20h, 0CCh, 0CDh, 2, 2Ah
    db 0B9h, 20h, 24h
; __int16 byte_632
byte_632  db 20h, 0BAh, 20h, 2, 2Ah, 0BAh, 20h, 24h
          ; DATA XREF: SOME_PRINTING_THREE_sub_14+21o
; __int16 byte_634
byte_634  db 20h, 0C8h, 0CDh, 2, 2Ah, 0BCh, 20h, 24h
          ; DATA XREF: SOME_PRINTING_THREE_sub_14+2Co
; __int16 press_a_key_text
press_a_key_text db 0C9h, 0CDh, 2, 14h, 0BBh, 0Dh, 0BAh, 5 dup(20h), 50h
					; DATA XREF: SOME_PRINTING_show_msg_box_sub_13+7o
    db 72h, 65h, 2 dup(73h), 20h, 61h, 20h, 4Bh, 65h, 79h ;
    db 5 dup(20h), 0BAh, 0Dh, 0C8h, 0CDh, 2, 14h, 0BCh, 24h ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
          ;
ENDIF
ENDIF
     
IFNDEF CLEANUP       
IFDEF DIRECT_START
  db 0d7h dup(EMPTY)
ELSE          
          ; byte_630 = grafic card selection
          ; ---------
					; §  F1	  CGA	   4   colors
					; §  F2	  EGA	   16  colors
					; §  F3	  Tandy	   16  colors
					; §  F4	  VGA	   16  colors
					; §  F5	  HERCULES 2 colors
          ; ---------
grafic_card_types_text_offset dw 568h	; DATA XREF: GFX_SELECT_MENU_sub_9+3Dr
					; the offsets at end are the switch HERCULES and VGA offsets
					;
					; cs:grafic_card_types_text_offset[n] is the offset to the grafic card text line
					;
					; CGA
		dw 591h			; EGA
		dw 5BAh			; TANDY
		dw 60Ch			; HERCULES
		dw 5E3h			; VGA
text_gfx_menu	db 20h,	0BAh, 2	dup(20h), 46h, 31h, 3 dup(20h),	43h, 47h ;
		db 41h,	6 dup(20h), 34h, 3 dup(20h), 63h, 6Fh, 6Ch, 6Fh	;
		db 72h,	73h, 0Ah dup(20h), 0BAh, 20h, 24h, 20h,	0BAh, 2	dup(20h) ;
		db 46h,	32h, 3 dup(20h), 45h, 47h, 41h,	6 dup(20h), 31h	;
		db 36h,	2 dup(20h), 63h, 6Fh, 6Ch, 6Fh,	72h, 73h, 0Ah dup(20h) ;
		db 0BAh, 20h, 24h, 20h,	0BAh, 2	dup(20h), 46h, 33h, 3 dup(20h) ;
		db 54h,	61h, 6Eh, 64h, 79h, 4 dup(20h),	31h, 36h, 2 dup(20h) ;
		db 63h,	6Fh, 6Ch, 6Fh, 72h, 73h, 0Ah dup(20h), 0BAh, 20h ;
		db 24h,	20h, 0BAh, 2 dup(20h), 46h, 34h, 3 dup(20h), 56h ;
		db 47h,	41h, 6 dup(20h), 31h, 36h, 2 dup(20h), 63h, 6Fh	;
		db 6Ch,	6Fh, 72h, 73h, 0Ah dup(20h), 0BAh, 20h,	24h, 20h ;
		db 0BAh, 2 dup(20h), 46h, 35h, 3 dup(20h), 48h,	45h, 52h ;
		db 43h,	55h, 4Ch, 45h, 53h, 20h, 32h, 20h, 63h,	6Fh, 6Ch ;
		db 6Fh,	72h, 73h, 0Ch dup(20h),	0BAh, 20h, 24h ;
					;
					; 5 (16bit offset) table in front
					; each line is 41 bytes
					; line-start+5 is the nr behind	the F-Char
					;  §  F1   CGA	    4	colors		§ $
					;  §  F2   EGA	    16	colors		§ $
					;  §  F3   Tandy    16	colors		§ $
					;  §  F4   VGA	    16	colors		§ $
					;  §  F5   HERCULES 2 colors		§ $
ENDIF          
ENDIF
     
IFNDEF CLEANUP  
IFDEF DIRECT_START

  db 6Ah dup(EMPTY)

ELSE
          
; __int16 change_insert_disk_text
change_insert_disk_text	db 2 dup(0Dh), 3, 0Bh, 4, 87h, 43h, 68h, 61h, 6Eh, 67h
					; DATA XREF: START_GAME_DOES_FILE_EXIST_sub_19+9Bo
    db 65h, 20h, 44h, 69h, 73h, 6Bh, 5, 2 dup(0Dh), 50h, 6Ch
    db 65h, 61h, 73h, 65h, 20h, 69h, 6Eh, 73h, 65h, 72h, 74h
    db 20h, 74h, 68h, 65h, 20h, 64h, 69h, 73h, 6Bh, 20h, 6Ch
    db 61h, 62h, 65h, 6Ch, 65h, 64h, 0Dh
text_drive_name_placeholder db 20h dup(31h), 0Dh, 69h, 6Eh, 20h, 74h, 68h, 65h,	20h
					; DATA XREF: START_GAME_DOES_FILE_EXIST_sub_19+7Fo
					; START_GAME_DOES_FILE_EXIST_sub_19+8Ao
    db 63h, 75h, 2 dup(72h), 65h, 6Eh, 74h, 20h, 64h, 72h
    db 69h, 76h, 65h, 2Eh, 24h
    
ENDIF    
ENDIF

IFNDEF CLEANUP      
IFDEF DIRECT_START
  db 186h dup(EMPTY)
ELSE    
    
; __int16 text_no_joystick_card_detected
text_no_joystick_card_detected db 2 dup(0Dh), 3, 10h, 4, 87h, 50h, 72h,	6Fh, 62h, 6Ch
					; DATA XREF: JOYSTICK_STUFF_sub_29+1Bo
    db 65h, 6Dh, 5, 2 dup(0Dh), 8 dup(20h), 4Eh, 4Fh, 20h
    db 4Ah, 4Fh, 59h, 53h, 54h, 49h, 43h, 4Bh, 20h, 43h, 41h
    db 52h, 44h, 20h, 44h, 45h, 54h, 45h, 43h, 54h, 45h, 44h
    db 2Eh, 24h
text_joystick_calibration db 2 dup(0Dh), 3, 0Ah, 4Ah, 6Fh, 79h,	73h, 74h, 69h, 63h
					; DATA XREF: JOYSTICK_STUFF2_sub_30+1Eo
    db 6Bh, 20h, 43h, 61h, 6Ch, 69h, 62h, 72h, 61h, 74h, 69h
    db 6Fh, 6Eh, 2 dup(0Dh), 50h, 6Ch, 65h, 61h, 73h, 65h
    db 20h, 68h, 6Fh, 6Ch, 64h, 20h, 73h, 74h, 69h, 63h, 6Bh
    db 20h, 61h, 74h, 20h, 70h, 6Fh, 73h, 69h, 74h, 69h, 6Fh
    db 6Eh, 20h, 73h, 68h, 6Fh, 77h, 6Eh, 2Eh, 0Dh, 50h, 75h
    db 73h, 68h, 20h, 61h, 63h, 74h, 69h, 6Fh, 6Eh, 20h, 62h
    db 75h, 2 dup(74h), 6Fh, 6Eh, 20h, 61h, 6Eh, 64h, 20h
    db 74h, 68h, 65h, 6Eh, 20h, 72h, 65h, 6Ch, 65h, 61h, 73h
    db 65h, 2Eh, 0Dh, 48h, 6Fh, 6Ch, 64h, 20h, 73h, 74h, 69h
    db 63h, 6Bh, 20h, 61h, 74h, 20h, 74h, 68h, 69h, 73h, 20h
    db 70h, 6Fh, 73h, 69h, 74h, 69h, 6Fh, 6Eh, 20h, 75h, 6Eh
    db 74h, 69h, 6Ch, 0Dh, 70h, 6Fh, 73h, 69h, 74h, 69h, 6Fh
    db 6Eh, 20h, 72h, 65h, 71h, 75h, 65h, 73h, 74h, 20h, 63h
    db 68h, 61h, 6Eh, 67h, 65h, 73h, 2Eh, 24h
; __int16 text_joystick_calibrate_success
text_joystick_calibrate_success	db 20h,	0C9h, 3	dup(0CDh), 0BBh, 20h, 0Dh, 20h,	0BAh
					; DATA XREF: JOYSTICK_STUFF2_sub_30+47o
					; JOYSTICK_STUFF2_sub_30+7Bo ...
byte_378	db 20h			; DATA XREF: JOYSTICK_STUFF2_sub_30+39w
					; JOYSTICK_STUFF2_sub_30+77w ...
    db 2 dup(20h), 0BAh, 20h, 0Dh, 20h, 0BAh, 20h
byte_376	db 20h			; DATA XREF: JOYSTICK_STUFF2_sub_30+43w
					; JOYSTICK_STUFF2_sub_30+6Dw ...
    db 20h, 0BAh, 20h, 0Dh, 20h, 0BAh, 2 dup(20h)
byte_377	db 20h			; DATA XREF: JOYSTICK_STUFF2_sub_30+3Fw
					; JOYSTICK_STUFF2_sub_30+73w ...
    db 0BAh, 20h, 0Dh, 20h, 0C8h, 3 dup(0CDh), 0BCh, 20h, 24h
text_joystick_calibrated_success2 db 2 dup(0Dh), 3, 10h, 47h, 2	dup(4Fh), 44h, 20h, 4Ah
					; DATA XREF: JOYSTICK_STUFF2_sub_30+115o
    db 4Fh, 42h, 20h, 2 dup(0Dh), 3, 8, 4Ah, 6Fh, 79h, 73h
    db 74h, 69h, 63h, 6Bh, 20h, 6Eh, 6Fh, 77h, 20h, 43h, 41h
    db 4Ch, 49h, 42h, 52h, 41h, 54h, 45h, 44h, 20h, 21h, 0Dh
    db 3, 8, 50h, 72h, 65h, 2 dup(73h), 20h, 61h, 20h, 4Bh
    db 65h, 79h, 20h, 6Fh, 72h, 20h, 74h, 68h, 65h, 20h, 42h
    db 75h, 2 dup(74h), 6Fh, 6Eh, 24h
; __int16 text_joystick_calibration_error
text_joystick_calibration_error	db 2 dup(0Dh), 3, 10h, 4, 87h, 50h, 72h, 6Fh, 62h, 6Ch
					; DATA XREF: JOYSTICK_STUFF2_sub_30+104o
    db 65h, 6Dh, 5, 2 dup(0Dh), 3, 0Ah, 43h, 61h, 6Ch, 69h
    db 62h, 72h, 61h, 74h, 69h, 6Fh, 6Eh, 20h, 45h, 2 dup(52h)
    db 4Fh, 52h, 20h, 21h, 0Dh, 3, 7, 50h, 6Ch, 65h, 61h, 73h
    db 65h, 2Ch, 63h, 68h, 65h, 63h, 6Bh, 20h, 79h, 6Fh, 75h
    db 72h, 20h, 6Ah, 6Fh, 79h, 73h, 74h, 69h, 63h, 6Bh, 2Eh
    db 24h

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================


; void __usercall GAME_START_sub_1(__int16 unknown_@<si>)
GAME_START_sub_1 proc near		; CODE XREF: EXE_HEADER_sub_2+8Ep
					; EXE_HEADER_sub_2+B2p
    push  ds
    push  es
    push  si
    push  di
    push  bx
    push  cx
    cld

loc_556:				; CODE XREF: GAME_START_sub_1+47j
    mov ax, si
    shr ax, 1
    shr ax, 1
    shr ax, 1
    shr ax, 1
    mov dx, ds
    add dx, ax
    mov ds, dx
    and si, 0Fh
    mov ax, di
    shr ax, 1
    shr ax, 1
    shr ax, 1
    shr ax, 1
    mov dx, es
    add dx, ax
    mov es, dx
    and di, 0Fh
		mov	ax, 512
    sub cx, ax
    sbb bx, 0
    jnb short loc_555
    add ax, cx
    xor bx, bx
    xor cx, cx

loc_555:				; CODE XREF: GAME_START_sub_1+35j
    push  cx
    mov cx, ax
    rep movsb
    pop cx
    mov ax, cx
    or  ax, bx
    jnz short loc_556
    pop cx
    pop bx
    pop di
    pop si
    pop es
    pop ds
    retn
GAME_START_sub_1 endp


; =============== S U B R O U T I N E =======================================


EXE_HEADER_sub_2 proc far		; CODE XREF: GAME_START_sub_7+9Bp
    push  bx
    test  cs:byte_55, 0C0h
    jnz short loc_557
    xor ax, ax
    clc
    pop bx
		retn			; near ret from	far proc - manually fixed stack?
; ---------------------------------------------------------------------------

loc_557:				; CODE XREF: EXE_HEADER_sub_2+7j
		mov	cs:word_558, ax	; something with someway_cs_registe_value1 - lea instruction
		mov	cs:some_register_cs_value, dx ;	= cs
		mov	cs:word_62, cx	; = some_game_ptr.ofs
		mov	cs:some_game_pointer_seg, bx ; = some_game_ptr.segm
		mov	cs:exe_pointer.ofs, si ; = 0
		mov	cs:exe_pointer.segm, ds	; = somway_exe_buffer_seg + 10h
    mov ah, 50h
		mov	bx, cs:new_psp_seg
    int 21h   ; DOS - 2+ internal - SET PSP SEGMENT
          ; BX = segment address of new PSP
    push  es
    push  ax
    push  ds
    xor ax, ax
    mov es, ax
    assume es:nothing
		lds	ax, dword ptr cs:saved_int1_ptr.ofs
    mov es:4, ax
    mov word ptr es:6, ds
    pop ds
    pop ax
    pop es
    assume es:nothing
    cld
		mov	cs:pointer3.ofs, di
		mov	cs:pointer3.segm, es
		lds	si, dword ptr cs:exe_pointer.ofs ; unknown_@   .ofs seems wrong???
    test  cs:byte_55, 40h
    jz  short loc_560
    jmp loc_561
; ---------------------------------------------------------------------------

loc_560:				; CODE XREF: EXE_HEADER_sub_2+62j
		cmp	[si+EXE_Header.signature], 'ZM' ; 'MZ' or 'ZM' exe header signature??
    jz  short loc_562
    stc
    pop bx
		retn			; near ret from	far proc - manually fixed stack?
; ---------------------------------------------------------------------------

loc_562:				; CODE XREF: EXE_HEADER_sub_2+6Bj
		mov	bx, [si+EXE_Header.headersize] ; exe Header size
    xor ax, ax
		shl	bx, 1		; bx *=	2;
    rcl ax, 1
		shl	bx, 1		; bx *=	2;
    rcl ax, 1
		shl	bx, 1		; bx *=	2;
    rcl ax, 1
		shl	bx, 1		; bx *=	2;
		rcl	ax, 1		;
					;
					; ==> bx *= 16
					; ==> ax contains the hi word
					;
					; results in a 32bit numbers in	ax:bx
					;
					; uint32_t result = header_paragraphs *	16;
					; ax ==	(result	>> 16));
					; bx ==	(result	& 0xFFFF));
		les	di, dword ptr cs:pointer3.ofs
    mov cx, bx
    mov bx, ax
		call	GAME_START_sub_1
    mov dx, bx
    mov si, cx    ; unknown_@
		mov	bx, cs:some_game_pointer_seg
    mov cx, cs:word_62
    sub cx, si
IFDEF WASM_BINARY_EQUAL
  db 1Bh,0DAh
ELSE
  sbb bx, dx
ENDIF    
    
    mov cs:some_game_pointer_seg, bx
    mov cs:word_62, cx
		les	di, dword ptr cs:exe_pointer.ofs
		call	GAME_START_sub_1
    mov bp, es
		les	bx, dword ptr cs:pointer3.ofs
    mov cx, es:[bx+6]
    jcxz  short loc_563
    mov di, es:[bx+18h]
    add di, bx

loc_564:				; CODE XREF: EXE_HEADER_sub_2+D8j
    mov si, es:[di]
    mov ax, es:[di+2]
    add ax, bp
    mov ds, ax
    add [si], bp
    add di, 4
    loop  loc_564

loc_563:				; CODE XREF: EXE_HEADER_sub_2+C0j
		les	si, dword ptr cs:pointer3.ofs
		mov	ax, es:[si+EXE_Header.initSP]
		mov	cs:register_sp_value, ax
		mov	ax, es:[si+EXE_Header.initSS]
    add ax, bp
		mov	cs:register_ss_value, ax
		mov	ax, es:[si+EXE_Header.initCS]
    add ax, bp
		mov	cs:exe_cs_ip_ptr.segm, ax
		mov	ax, es:[si+EXE_Header.initIP]
		mov	cs:exe_cs_ip_ptr.ofs, ax
		mov	es, cs:new_psp_seg
    cld
    mov di, es
		mov	ax, cs:register_sp_value
		mov	dx, cs:register_ss_value
    mov cx, cs:word_62
		mov	bx, cs:some_game_pointer_seg
    cli
		mov	ss, dx		;
					;
					; --
					;
					; prepare registers for	exe start
					;
					;
					; --
    mov sp, ax
    mov ds, di
    xor ax, ax
    push  ax
    sti
		jmp	dword ptr cs:exe_cs_ip_ptr.ofs ; jump into game	code
; ---------------------------------------------------------------------------

loc_561:				; CODE XREF: EXE_HEADER_sub_2+64j
    cli
		mov	ax, cs:new_psp_seg
    mov es, ax
    mov ds, ax
    mov ss, ax
    mov sp, 0FFFFh
    xor bx, bx
    push  bx
    push  ax
		mov	ax, size sPSP	; maybe	PSP size
    push  ax
    mov ax, bx
    mov cx, bx
    mov dx, bx
    mov bp, bx
    mov si, bx
    mov di, bx
    sti
    retf
EXE_HEADER_sub_2 endp


; =============== S U B R O U T I N E =======================================


GAME_START_sub_3 proc near		; CODE XREF: GAME_START_sub_3+101j
          ; read_some_file_sub_4+1EDp
    push  es
    push  di
    mov cx, 80h
    mov ax, ds
    mov es, ax
    assume es:seg000
		mov	di, 301h	; its not in seg000!!!
    xor ax, ax
    rep stosw
    pop di
    pop es
    assume es:nothing
    push  es
    xor ax, ax
    mov es, ax
    assume es:nothing
    sub di, es:4
    pop es
    assume es:nothing
    mov ax, di
    shr ax, 1
    shr ax, 1
    shr ax, 1
    shr ax, 1
    mov cx, es
    add cx, ax
    mov es, cx
    and di, 0Fh
    push  es
    xor ax, ax
    mov es, ax
    assume es:nothing
    add di, es:4
    pop es
    assume es:nothing
    push  ds
    push  es
    push  si
    push  di
    mov cx, 4
		mov	di, offset byte_57 ; byte_57 holds 4 bytes - see rep movsb
    mov ax, cs
    mov es, ax
    assume es:seg000
		lds	si, dword ptr cs:another_pointer2.ofs
    mov ax, si
    shr ax, 1
    shr ax, 1
    shr ax, 1
    shr ax, 1
    mov dx, ds
    add ax, dx
    mov ds, ax
    and si, 0Fh
		mov	cs:another_pointer2.ofs, si
		mov	cs:another_pointer2.segm, ds
		add	cs:another_pointer2.ofs, cx
    rep movsb
    pop di
    pop si
    pop es
    assume es:nothing
    pop ds
    mov dx, cs:word_60
    inc dx
    cmp cs:byte_57, 0
    jnz short loc_565
    jmp loc_566
; ---------------------------------------------------------------------------

loc_565:				; CODE XREF: GAME_START_sub_3+82j
    push  ds
    push  es
    push  di
    xor ch, ch
    mov cl, cs:byte_57
    mov di, 201h
    mov ax, ds
    mov es, ax
    assume es:seg000
		mov	ds, cs:another_pointer2.segm
		mov	si, cs:another_pointer2.ofs
		add	cs:another_pointer2.ofs, cx
    rep movsb
    mov cl, cs:byte_57
    xor ch, ch
    mov di, 1
		add	cs:another_pointer2.ofs, cx
    rep movsb
    mov cl, cs:byte_57
    mov di, 101h
		add	cs:another_pointer2.ofs, cx
    rep movsb
    pop di
    pop es
    assume es:nothing
    pop ds
    xor ch, ch
    mov cl, cs:byte_57
    xor ah, ah
    mov bx, 1

loc_567:				; CODE XREF: GAME_START_sub_3+EBj
    mov al, [bx+200h]
    mov si, ax
    mov dl, [si+301h]
    mov [bx+402h], dl
    mov [si+301h], bl
    inc bx
    loop  loc_567
    mov dx, cs:word_60
    inc dx
    mov cx, 1

loc_124:				; CODE XREF: GAME_START_sub_3+123j
					; GAME_START_sub_3+16Ej
    dec dx
    jnz short loc_568

loc_577:				; CODE XREF: GAME_START_sub_3+192j
    cmp cs:byte_569, 0
    jz  short locret_570
		jmp	GAME_START_sub_3
; ---------------------------------------------------------------------------

locret_570:				; CODE XREF: GAME_START_sub_3+FFj
    retn
; ---------------------------------------------------------------------------

loc_568:				; CODE XREF: GAME_START_sub_3+F7j
    push  ds
		mov	si, cs:another_pointer2.segm
    mov ds, si
		mov	si, cs:another_pointer2.ofs
    lodsb
		mov	cs:another_pointer2.ofs, si
    pop ds
    mov bx, ax
    cmp byte ptr [bx+301h], 0
    jnz short loc_571
    stosb
    jmp short loc_124
; ---------------------------------------------------------------------------

loc_571:				; CODE XREF: GAME_START_sub_3+120j
    mov bl, [bx+301h]
    xor ax, ax
    push  ax
    jmp short loc_128
; ---------------------------------------------------------------------------

loc_129:				; CODE XREF: GAME_START_sub_3+164j
					; GAME_START_sub_3+174j
    mov bp, ax
    cmp byte ptr ds:[bp+301h], 0
    jz  short loc_572
    cmp bl, ds:[bp+301h]
    ja  short loc_573
    mov al, bl
    mov bl, ds:[bp+301h]

loc_575:				; CODE XREF: GAME_START_sub_3+152j
    mov bl, [bx+402h]
    or  bl, bl
    jz  short loc_574
    cmp bl, al
    jb  short loc_128
    jmp short loc_575
; ---------------------------------------------------------------------------

loc_573:				; CODE XREF: GAME_START_sub_3+13Dj
    mov bl, ds:[bp+301h]

loc_128:				; CODE XREF: GAME_START_sub_3+12Cj
					; GAME_START_sub_3+150j
    mov al, [bx+100h]
    mov ah, bl
    push  ax
    xor ah, ah
    mov al, [bx]
    jmp short loc_129
; ---------------------------------------------------------------------------

loc_574:				; CODE XREF: GAME_START_sub_3+14Cj
    mov ax, bp

loc_572:				; CODE XREF: GAME_START_sub_3+136j
    stosb
    pop ax
    or  ax, ax
    jnz short loc_576
    jmp short loc_124
; ---------------------------------------------------------------------------

loc_576:				; CODE XREF: GAME_START_sub_3+16Cj
    mov bl, ah
    xor ah, ah
    jmp short loc_129
; ---------------------------------------------------------------------------

loc_566:				; CODE XREF: GAME_START_sub_3+84j
    push  ds
    push  es
    mov cx, cs:word_60
    push  cx
		mov	ds, cs:another_pointer2.segm
		mov	si, cs:another_pointer2.ofs
		add	cs:another_pointer2.ofs, cx
    rep movsb
    pop cx
    pop es
    pop ds
    jmp loc_577
GAME_START_sub_3 endp ;	sp-analysis failed


; =============== S U B R O U T I N E =======================================


read_some_file_sub_4 proc near		; CODE XREF: GAME_START_sub_7+2Ap
    mov ax, cs
    mov ds, ax
		mov	dx, bx		; bx = gfx-block start = offset	filename
    mov ah, 3Dh
    mov al, 0
    int 21h   ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
          ; DS:DX -> ASCIZ filename
          ; AL = access mode
          ; 0 - read
    jnb short loc_578

loc_136:        ; CODE XREF: read_some_file_sub_4+45j
          ; read_some_file_sub_4+4Aj ...
    stc
    retn
; ---------------------------------------------------------------------------

loc_578:        ; CODE XREF: read_some_file_sub_4+Cj
    mov si, bx
    mov bx, ax
    mov ah, 3Fh
    mov cl, cs:byte_55
    test  cl, 18h
    jnz short loc_579
		lds	cx, dword ptr cs:maybe_exe_buffer.ofs
    mov cs:word_44, 0FFFFh
    mov cs:word_45, 0FFFFh
    jmp loc_580
; ---------------------------------------------------------------------------

loc_579:        ; CODE XREF: read_some_file_sub_4+1Ej
    test  cl, 10h
    jz  short loc_581
    mov cx, 2
		lds	dx, dword ptr cs:maybe_exe_buffer.ofs
    int 21h   ; DOS - 2+ - READ FROM FILE WITH HANDLE
          ; BX = file handle, CX = number of bytes to read
          ; DS:DX -> buffer
    jb  short loc_136
IFDEF BINARY_EQUAL
    db 3dh,02h,00h
ELSE    
    cmp  ax, 2
ENDIF    
    
    jnz short loc_136
    mov di, dx
    mov cx, [di]
IFDEF WASM_BINARY_EQUAL
  db 86h,0CDh
ELSE
    xchg  cl, ch
ENDIF
    mov di, cx
		mov	al, cs:[si+gfx_block_t.byte_12h]
    xor ah, ah
    shl ax, 1
    shl ax, 1
    mov dx, ax
    xor cx, cx
    mov al, 1
    mov ah, 42h
    int 21h   ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
          ; AL = method: offset from present location
    jb  short loc_136
		lds	dx, dword ptr cs:maybe_exe_buffer.ofs
    mov ah, 3Fh
    mov cx, 4
    int 21h   ; DOS - 2+ - READ FROM FILE WITH HANDLE
          ; BX = file handle, CX = number of bytes to read
          ; DS:DX -> buffer
    jb  short loc_136
    
IFDEF BINARY_EQUAL
    db 3dh,04h,00h
ELSE
    cmp  ax, 4
ENDIF    
    
    jnz short loc_136
    mov si, dx
    mov cx, [si]
IFDEF WASM_BINARY_EQUAL
    db 86h,0CDh
ELSE
    xchg  cl, ch
ENDIF    
    mov dx, [si+2]
IFDEF WASM_BINARY_EQUAL
    db 86h,0D6h
ELSE
    xchg  dl, dh
ENDIF   
    shl di, 1
    shl di, 1
    add di, 2
    add dx, di
    adc cx, 0
    mov al, 0
    mov ah, 42h
    int 21h   ; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
          ; AL = method: offset from beginning of file
    jb  short loc_139

loc_581:        ; CODE XREF: read_some_file_sub_4+39j
		lds	dx, dword ptr cs:maybe_exe_buffer.ofs
    mov ah, 3Fh
    mov cx, 8
    int 21h   ; DOS - 2+ - READ FROM FILE WITH HANDLE
          ; BX = file handle, CX = number of bytes to read
          ; DS:DX -> buffer
    jb  short loc_139
    
IFDEF BINARY_EQUAL
    db 3dh,08h,00h    
ELSE
    cmp ax, 8
ENDIF   
    
    jz  short loc_582

loc_139:        ; CODE XREF: read_some_file_sub_4+9Aj
          ; read_some_file_sub_4+A8j
    stc
    retn
; ---------------------------------------------------------------------------

loc_582:        ; CODE XREF: read_some_file_sub_4+ADj
		lds	bp, dword ptr cs:maybe_exe_buffer.ofs
    mov ax, ds:[bp+0]
    mov cx, ds:[bp+2]
IFDEF WASM_BINARY_EQUAL
    db 86h,0C4h
    db 86h,0CDh
ELSE
    xchg  al, ah
    xchg  cl, ch
ENDIF
    mov cs:word_44, cx
    mov cs:word_45, ax
    mov ax, ds:[bp+4]
    mov cx, ds:[bp+6]
IFDEF WASM_BINARY_EQUAL
    db 86h,0C4h
    db 86h,0CDh
ELSE
    xchg  al, ah
    xchg  cl, ch
ENDIF     
		mov	cs:some_game_ptr.ofs, cx
		mov	cs:some_game_ptr.segm, ax
    mov si, cx
    mov di, ax
		lds	cx, dword ptr cs:maybe_exe_buffer.ofs
    add si, cx
    adc di, 0
    sub si, cs:word_44
    sbb di, cs:word_45
    add si, 10h
    adc di, 0
    mov cx, si
    shr di, 1
    rcr si, 1
    shr di, 1
    rcr si, 1
    shr di, 1
    rcr si, 1
    shr di, 1
    rcr si, 1
    mov ax, ds
    add ax, si
    mov ds, ax
    and cx, 0Fh

loc_580:        ; CODE XREF: read_some_file_sub_4+33j
		mov	cs:another_far_ptr.ofs,	cx
		mov	cs:another_far_ptr.segm, ds
		mov	cs:another_pointer2.ofs, cx
		mov	cs:another_pointer2.segm, ds
    mov si, cs:word_44
    mov di, cs:word_45
		mov	cs:also_a_pointer.ofs, 0
		mov	cs:also_a_pointer.segm,	0
		lds	dx, dword ptr cs:another_far_ptr.ofs

loc_586:        ; CODE XREF: read_some_file_sub_4+18Dj
    mov cx, dx
    shr cx, 1
    shr cx, 1
    shr cx, 1
    shr cx, 1
    mov ax, ds
    add ax, cx
    mov ds, ax
    and dx, 0Fh
		mov	ax, 48000
    sub si, ax
    sbb di, 0
    jnb short loc_583
    add si, ax
    mov ax, si
    xor si, si
    xor di, di

loc_583:        ; CODE XREF: read_some_file_sub_4+165j
    mov cx, ax
    mov ah, 3Fh
    int 21h   ; DOS - 2+ - READ FROM FILE WITH HANDLE
          ; BX = file handle, CX = number of bytes to read
          ; DS:DX -> buffer
    jnb short loc_584
    retn
; ---------------------------------------------------------------------------

loc_584:        ; CODE XREF: read_some_file_sub_4+175j
		add	cs:also_a_pointer.ofs, ax
		adc	cs:also_a_pointer.segm,	0
    add dx, ax
    cmp ax, cx
    jnz short loc_585
    mov ax, si
    or  ax, di
    jnz short loc_586

loc_585:        ; CODE XREF: read_some_file_sub_4+187j
    mov ah, 3Eh
    int 21h   ; DOS - 2+ - CLOSE A FILE WITH HANDLE
          ; BX = file handle
    test  cs:byte_55, 18h
    jz  short loc_587
		les	di, dword ptr cs:maybe_exe_buffer.ofs
    push  es
    xor ax, ax
    mov es, ax
    assume es:nothing
    mov es:4, di
    pop es
    assume es:nothing
		mov	cs:another_far_ptr.ofs,	di
		mov	cs:another_far_ptr.segm, es
		lds	si, dword ptr cs:some_game_ptr.ofs
    mov cx, ds
    add si, 10h
    add cx, 0
    add si, di
    adc cx, 0
    mov bx, si
    shr cx, 1
    rcr si, 1
    shr cx, 1
    rcr si, 1
    shr cx, 1
    rcr si, 1
    shr cx, 1
    rcr si, 1
    mov ax, es
    add ax, si
		mov	cs:maybe_exe_buffer.segm, ax
    inc ax
    mov ds, ax
    and bx, 0Fh
		mov	cs:maybe_exe_buffer.ofs, bx
    cld
		call	GAME_START_sub_3
    clc
    retn
; ---------------------------------------------------------------------------

loc_587:        ; CODE XREF: read_some_file_sub_4+199j
		lds	si, dword ptr cs:also_a_pointer.ofs
		mov	cs:some_game_ptr.ofs, si
		mov	cs:some_game_ptr.segm, ds
    clc
    retn
read_some_file_sub_4 endp


; =============== S U B R O U T I N E =======================================


GAME_START_sub_5 proc near		; CODE XREF: GAME_START_sub_7+B7p
    push  bx
    mov al, cs:byte_55
    test  al, 20h
    jz  short loc_588
    test  al, 10h
    jnz short loc_589
		mov	ax, cs:somway_exe_buffer_seg
    mov ds, ax
    mov es, ax
    mov bp, ax
    xor si, si
    xor di, di
    mov cx, [si]
    shr cx, 1
    shr cx, 1

loc_590:				; CODE XREF: GAME_START_sub_5+41j
    mov ax, [si]
    mov bx, [si+2]
    shr bx, 1
    rcr ax, 1
    shr bx, 1
    rcr ax, 1
    shr bx, 1
    rcr ax, 1
    shr bx, 1
    rcr ax, 1
    add ax, bp
    mov [si+2], ax
    and word ptr [si], 0Fh
    add si, 4
    loop  loc_590

loc_589:				; CODE XREF: GAME_START_sub_5+Bj
    mov al, cs:byte_55
    test  al, 0C0h
    jnz short loc_591
		les	bx, dword ptr cs:far_ptr3.ofs
    mov ax, es
    shr ax, 1
    rcr bx, 1
    shr ax, 1
    rcr bx, 1
    shr ax, 1
    rcr bx, 1
    shr ax, 1
    rcr bx, 1
    inc bx
		mov	es, cs:somway_exe_buffer_seg
    mov ah, 4Ah
    int 21h   ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
          ; ES = segment address of block to change
          ; BX = new size in paragraphs

loc_591:				; CODE XREF: GAME_START_sub_5+49j
    clc
    pop bx
    retn
; ---------------------------------------------------------------------------

loc_588:				; CODE XREF: GAME_START_sub_5+7j
    pop bx
    retn
GAME_START_sub_5 endp


; =============== S U B R O U T I N E =======================================


GAME_START_sub_6 proc near		; CODE XREF: GAME_START_sub_7+25p
    push  bx
    xor ax, ax
		mov	cs:far_ptr3.ofs, ax
		mov	cs:far_ptr3.segm, ax
    mov al, cs:byte_55
    test  al, 20h
    jnz short loc_592
		mov	cs:far_ptr3.ofs, size sPSP
		mov	dx, cs:maybe_exe_buffer.segm
		add	cs:maybe_exe_buffer.segm, 16
		mov	cs:new_psp_seg,	dx
    mov ah, 26h
    int 21h   ; DOS - CREATE PSP
          ; DX = segment number at which to set up PSP
		mov	dx, sPSP.cmdtail_or_dta	; dta_offs
		mov	ds, cs:new_psp_seg
    mov ah, 1Ah
    int 21h   ; DOS - SET DISK TRANSFER AREA ADDRESS
          ; DS:DX -> disk transfer buffer
		mov	word ptr ds:sPSP.int_22.segm, cs
		mov	word ptr ds:sPSP.int_22, offset	loc_600	; TODO:	could be only a	overwrite buffer - or the real code that resists there
    clc
    pop bx
    retn
; ---------------------------------------------------------------------------

loc_592:				; CODE XREF: GAME_START_sub_6+11j
    xor ax, ax
    mov ds, ax
    assume ds:nothing
    lea ax, ds:((90*sizeof ptr16)+1) ; ??? Interrupt[90]+1 ???
    ; Interrupt[155]
    mov ds:(155*sizeof ptr16+ptr16.ofs), ax 
    mov word ptr ds:(155*sizeof ptr16+ptr16.segm), cs
    
    ;====
    
IFNDEF __WASM__ ; Issue: https://github.com/open-watcom/open-watcom-v2/issues/841
		mov	cx, lengthof maybe_10_ptr ; item count not bytes ; WASM sets 1Eh, UASM/MASM 0Ah
ELSE
    mov	cx, 10
ENDIF    
    mov ax, cs
    mov ds, ax
    assume ds:seg000
		lea	si, maybe_10_ptr

loc_594:				; CODE XREF: GAME_START_sub_6+6Bj
		mov	ax, [si+ptr16.ofs]
		or	ax, [si+ptr16.segm]
    jz  short loc_593
    add si, size ptr16
    loop  loc_594
    stc
    pop bx
    retn
; ---------------------------------------------------------------------------

loc_593:				; CODE XREF: GAME_START_sub_6+66j
		mov	ax, cs:maybe_exe_buffer.segm
		mov	[si+ptr16.segm], ax
		mov	[si+ptr16.ofs],	0
    clc
    pop bx
    retn
GAME_START_sub_6 endp


; =============== S U B R O U T I N E =======================================


GAME_START_sub_7 proc near		; CODE XREF: START_GAME_sub_22:loc_655p
    push  bx
    push  bx
    mov ah, 48h
    mov bx, 0FFFFh
    int 21h   ; DOS - 2+ - ALLOCATE MEMORY
          ; BX = number of 16-byte paragraphs desired
					; AX = segment of reserved block
					;
					; this call always fails (CF=1,	ax=8, bx=max available blocks)
    mov ah, 48h
    int 21h   ; DOS - 2+ - ALLOCATE MEMORY
          ; BX = number of 16-byte paragraphs desired
					; AX = segment of reserved block
		mov	cs:maybe_exe_buffer.segm, ax
		mov	cs:somway_exe_buffer_seg, ax
		mov	cs:maybe_exe_buffer.ofs, 0
    pop bx
		mov	al, cs:[bx+gfx_block_t.byte_13h]
    mov cs:byte_55, al
		call	GAME_START_sub_6
    jb  short loc_595
    call  read_some_file_sub_4
    jnb short loc_596

loc_595:				; CODE XREF: GAME_START_sub_7+28j
    stc
    pop bx
    retn
; ---------------------------------------------------------------------------

loc_596:				; CODE XREF: GAME_START_sub_7+2Dj
		les	si, dword ptr cs:some_game_ptr.ofs
    mov di, es
		add	cs:far_ptr3.ofs, si
		adc	cs:far_ptr3.segm, di
		les	si, dword ptr cs:far_ptr3.ofs
    mov di, es
		mov	ax, cs:somway_exe_buffer_seg
    shr di, 1
    rcr si, 1
    shr di, 1
    rcr si, 1
    shr di, 1
    rcr si, 1
    shr di, 1
    rcr si, 1
    inc si
    add ax, si
    mov es, ax
    xor di, di
		lds	cx, dword ptr cs:some_game_ptr.ofs
    mov bx, ds
		mov	ax, cs:somway_exe_buffer_seg
    
IFDEF BINARY_EQUAL
    db 05h,10h,00h
ELSE    
    add  ax, 10h
ENDIF    
    
    mov ds, ax
    xor si, si
    mov dx, cs
		mov	cs:someway_cs_registe_value1, dx
		mov	cs:someway_cs_registe_value2, dx
		mov	cs:someway_cs_registe_value3, dx
		mov	cs:someway_cs_registe_value4, dx
		lea	ax, someway_cs_registe_value1
		mov	cs:some_register_sp_value, sp
		mov	cs:some_register_ss_value, ss
		call	near ptr EXE_HEADER_sub_2 ; !!!!calls the game code
    jnb short loc_600
    stc
    pop bx
    retn
; ---------------------------------------------------------------------------

IFDEF __WASM__
loc_600:				; CODE XREF: GAME_START_sub_7+9Ej
ELSE
loc_600::
ENDIF
					; DATA XREF: GAME_START_sub_6+3Eo
    cli
		mov	sp, cs:some_register_sp_value
		mov	ss, cs:some_register_ss_value
    sti
    mov ah, 4Dh
    int 21h   ; DOS - 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
		mov	cs:subprogram_exit_code, al
		call	GAME_START_sub_5
    pop bx
    retn
GAME_START_sub_7 endp ;	sp-analysis failed


; =============== S U B R O U T I N E =======================================

; Attributes: noreturn

start_0   proc near   ; CODE XREF: startj

; FUNCTION CHUNK AT 11BB SIZE 000000A8 BYTES

    cld
    cli
    mov ax, cs
    mov ss, ax
    assume ss:seg000
    mov ds, ax
    mov es, ax
    assume es:seg000
    mov sp, offset stack_space_end_unk_342
    mov ah, 51h
    int 21h   ; DOS - 2+ internal - GET PSP SEGMENT
          ; Return: BX = current PSP segment
    mov cs:start_psp, bx
    mov ah, 30h
    int 21h   ; DOS - GET DOS VERSION
          ; Return: AL = major version number (00h for DOS 1.x)
    mov cs:dos_version, al
    sti
    
IFDEF DIRECT_START
    call SIMPLE_INIT_routine
ELSE    
    ; init does not use printers
    call  INIT_PART_init_stuff_sub_26 ; after that call the the_overwrite_buffer_begin gets used
ENDIF    
   
    call  read_config_and_resize_memory ; CF = 1 on error
    jb  short shutdown_cleanup ; shutdown on error

IFDEF __WASM__
main_menu_screen:
ELSE
main_menu_screen::          ; CODE XREF: start_0+2B4j start_0+2CAj ...  ; make label public available
ENDIF
    cld
    cli
    mov ax, cs
    mov ss, ax
    mov ds, ax
    mov es, ax
    mov sp, offset stack_space_end_unk_342
    sti
		lea	ax, maybe_10_ptr
IFNDEF __WASM__ ; Issue: https://github.com/open-watcom/open-watcom-v2/issues/841
		mov	cx, lengthof maybe_10_ptr ; item count not bytes ; WASM sets 1Eh, UASM/MASM 0Ah
ELSE
    mov	cx, 10
ENDIF 
    mov ax, cs
    mov ds, ax
		lea	si, maybe_10_ptr

loc_844:				; CODE XREF: start_0+53j
    les ax, [si]
    assume es:nothing
    mov bx, es
    or  ax, bx
		jz	short loc_843
    mov ah, 49h
    int 21h   ; DOS - 2+ - FREE MEMORY
          ; ES = segment address of area to be freed

loc_843:				; CODE XREF: start_0+4Aj
		add	si, size ptr16
		loop	loc_844
		lea	di, maybe_10_ptr
    mov ax, cs
    mov es, ax
    assume es:seg000
    xor ax, ax
IFNDEF __WASM__ ; Issue: https://github.com/open-watcom/open-watcom-v2/issues/841
		mov	cx, sizeof maybe_10_ptr ; WASM sets cx wrongly to 78h, UASM/MASM are ok
ELSE
    mov	cx, 28h
ENDIF    
    rep stosw

IFDEF DIRECT_START
  ; patch1 code
  patch1_code_begin:

    jmp start_game
  
  patch1_code_end:
  
  ;----
  ; keep all the offsets around intact
  patch1_size = patch1_code_end - patch1_code_begin
  patch1_rest_nops = 23h - patch1_size
  IF patch1_rest_nops LT 0
    .ERR <patch1 code too big>
  ENDIF
  db patch1_rest_nops dup(NOOP) ; nops
  ;----
ELSE
    ; original code (23h bytes)
		cmp	word ptr cs:IN_MAIN_MENU_selected_gfx_index, 0FFFFh
		jnz	short loc_845
    call  GFX_SELECT_MENU_sub_9

loc_845:				; CODE XREF: start_0+6Aj
    call  MAIN_MENU_sub_8

wait_key_loc_604:     ; CODE XREF: start_0+77j
    call  WAIT_F_KEY_sub_20
    cmp al, 3   ; Jump if above or equal: only F1-F3 are allowed
          ;   F1=Start Game
          ;   F2=Select Gfx
          ;   F3=Exit to DOS
    jnb short wait_key_loc_604
    call  LOADING_MSG_sub_16
    xor bx, bx
    mov bl, al
    shl bx, 1
    jmp cs:main_menu_jump_table[bx]
ENDIF    
; ---------------------------------------------------------------------------

IFDEF __WASM__
shutdown_cleanup:
ELSE
shutdown_cleanup::      ; CODE XREF: start_0+25j start_0+82j ; // :: for public label
ENDIF
          ; DATA XREF: ...
    xor ah, ah
		mov	al, cs:saved_video_mode
    int 10h   ; - VIDEO - SET VIDEO MODE
          ; AL = mode
    mov bx, cs:start_psp
    mov ah, 50h
    int 21h   ; DOS - 2+ internal - SET PSP SEGMENT
          ; BX = segment address of new PSP
    push  es
    push  ds
    xor ax, ax
    mov es, ax
    assume es:nothing
		lds	ax, dword ptr cs:saved_int1_ptr.ofs
    mov es:(1*sizeof ptr16+ptr16.ofs), ax
    mov word ptr es:(1*sizeof ptr16+ptr16.segm), ds
    pop ds
    pop es
    assume es:nothing
    push  es
    push  ds
    xor ax, ax
    mov es, ax
    assume es:nothing
    mov ax, cs
    mov ds, ax
    cld
		lea	si, saved_5_interrupt_pointers
		mov	di, (97h*sizeof ptr16)	; from Interrupt 151(0x97) 5 pointers saved
					; Interrupt[0x97 = 151]
					; Interrupt[152]
					; Interrupt[153]
					; Interrupt[154]
					; Interrupt[155]
					;
					; --------
		mov	cx, 5*sizeof ptr16		; 5*sizeof(far-pointer)
		rep movsb		; DS:SI	to address ES:DI
    
    ; was adlib sound used by game - then the F0 interrupt is overwritten?
		lds	si, es:(0F0h*sizeof ptr16)	; ------
					;
					; the game sets	Interrupt 0xF0 for sound stuff
					; (gets	not set	if the game is not started with	F1)
					;
					; 0:0x3C0 = Interrupt[240 == 0xF0]
					;
					; int_0xF0_proc:
					;   jmp	    short loc_D
					; aIfgmAdlib db	'IFGM ADLIB',0
					; loc_D:
					;   push    ds
					;   push    es
					;   push    si
					;   push    di
					;   push    bx
					;   push    cx
					;   push    bp
					;   cld
					;   mov	    bx,	cs
					;   mov	    ds,	bx
					;   xor	    bx,	bx
					;   mov	    bl,	ah
					;   call    cs:off_EFF[bx]
					;   pop	    bp
					;   pop	    cx
					;   pop	    bx
					;   pop	    di
					;   pop	    si
					;   pop	    es
					;   pop	    ds
					;   iret
					;
					;
					; before the exit the loader checks
					; if 'IFGM' is at the 2. byte of the Interrupt-F0-Proc
					;
					; --------
    mov ax, ds
    or  ax, si
		jz	short exit_program
    mov cx, [si+2]
    mov dx, [si+4]
		cmp	cx, 'FI'
		jnz	short exit_program
		cmp	dx, 'MG'
		jnz	short exit_program
    mov ah, 0Eh
		int	0F0h		; Int 0xF0 gets	overwritten by game with ADLIB sound stuff proc

exit_program:				; CODE XREF: start_0+CEj start_0+DAj ...
    pop ds
    pop es
    assume es:nothing
IFDEF __WASM__
just_exit:
ELSE
just_exit::    
ENDIF
    xor al, al
    mov ah, 4Ch
    int 21h   ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
start_0   endp ; sp-analysis failed ; AL = exit code


; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP  
IFDEF DIRECT_START
   
   db 4Ch dup(EMPTY)

ELSE

MAIN_MENU_sub_8	proc near		; CODE XREF: start_0:loc_845p
    call  SOME_PRINTING_TWO_sub_17
    mov al, 3
    mov cs:text_y_offset, al
    mov al, 15h
    mov cs:text_x_offset, al
    xor dx, dx
		lea	di, text_main_menu
    mov cx, 24h
    mov al, 20h
    rep stosb
		mov	si, cs:config_tat_game_name_string
    xor dx, dx

loc_812:				; CODE XREF: MAIN_MENU_sub_8+29j
    lodsb
		or	al, al		; until	0 reached
		jz	short loc_811
    inc dx
		jmp	short loc_812
; ---------------------------------------------------------------------------

loc_811:				; CODE XREF: MAIN_MENU_sub_8+26j
    shr dx, 1
    sub dx, 399h
    neg dx
    mov di, dx
		mov	si, cs:config_tat_game_name_string

loc_814:				; CODE XREF: MAIN_MENU_sub_8+40j
    lodsb
		or	al, al		; until	0 reached
		jz	short loc_813
    stosb
		jmp	short loc_814
; ---------------------------------------------------------------------------

loc_813:				; CODE XREF: MAIN_MENU_sub_8+3Dj
    xor dx, dx    ; y_@
    lea ax, text_main_menu2 ; text_offset_@
    call  SOME_PRINTING_sub_18
    retn
MAIN_MENU_sub_8 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP  
IFDEF DIRECT_START

  db 0A2h dup(EMPTY) ; nops

ELSE

GFX_SELECT_MENU_sub_9 proc near   ; CODE XREF: start_0+6Cp
          ; start_0:select_gfxp
    call  SOME_PRINTING_TWO_sub_17
    mov al, 3
    mov cs:text_y_offset, al
    mov al, 21
    mov cs:text_x_offset, al
    xor dx, dx    ; y_@
    lea ax, select_video_card_text ; text_offset_@ - "Select Video card"
    call  SOME_PRINTING_sub_18
		lea	di, grafic_type_supported_table	; fill uint8_t byte_90[5] with 0xFF
          ;
          ; one byte for each selectable grafic card?
    mov al, 0FFh
    mov cx, 5
    rep stosb   ; ES:DI[0-4] = 0xFF
		lea	di, grafic_type_supported_table
		mov	bx, cs:config_tat_gfx_table_offset
    xor dx, dx
    xor cx, cx

print_grafic_card_type:     ; CODE XREF: GFX_SELECT_MENU_sub_9+5Dj
		cmp	word ptr [bx], 0 ; the offset is 0 if the grafic card is not supported
					;
					; all grafic types are supported with the released alpha waves
					; version
					; so no	grafic card type gets skipped here
		jz	short loc_815
		mov	cs:[di], cl	; mark grafic type as supported	- non 0xFF
    inc di
    mov si, cx
    shl si, 1   ; si *= 2
    mov si, cs:grafic_card_types_text_offset[si]
    mov ax, dx
    add al, '1'         ; al is the gfx nr + '1' gives the correct ascii number for the Fn-Key
		mov	[si+5],	al	; si+5 =
					;
					; §  F>>1<<   CGA      4   colors	   § $
					;
					; the number behind the	F-Char
    mov ax, si    ; text_offset_@
          ;
          ; in the buffer is this
          ;  F1 CGA  4   colors
          ;  F2 EGA  16  colors
          ;  F3 Tandy  16  colors
          ;  F4 VGA  16  colors
          ;  F5 HERCULES 2 colors
          ;
          ; but the games shows VGA and HERCULES switched???
          ;
          ;  F1 CGA  4   colors
          ;  F2 EGA  16  colors
          ;  F3 Tandy  16  colors
          ;  F4 HERCULES 2 colors
          ;  F5 VGA  16  colors
          ;
					; the grafic_card_types_text_offset table
					; switches the last two	and renumbers the F keys accordingly
    push  dx
IFDEF WASM_BINARY_EQUAL
    db 86h,0F2h
ELSE
    xchg  dh, dl    ; x_@
ENDIF
    add dh, 4   ; y_@
    call  SOME_PRINTING_sub_18
    pop dx
    inc dx

loc_815:				; CODE XREF: GFX_SELECT_MENU_sub_9+33j
    add bx, 2
    inc cx
		cmp	cx, 5		; 5 types printed?
    jnz short print_grafic_card_type
    mov ax, dx
IFDEF WASM_BINARY_EQUAL
    db 86h,0F2h
ELSE
    xchg  dh, dl    ; x_@
ENDIF     
    add dh, 4   ; y_@
    lea ax, press_a_function_key_text ; text_offset_@ "Press a function key"
    call  SOME_PRINTING_sub_18

loc_168:        ; CODE XREF: GFX_SELECT_MENU_sub_9+77j
          ; GFX_SELECT_MENU_sub_9+8Dj
    mov ah, 1
    int 16h   ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
          ; Return: ZF clear if character in buffer
          ; AH = scan code, AL = character
          ; ZF set if no character in buffer
    jz  short loc_169
    xor ah, ah
    int 16h   ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
          ; Return: AH = scan code, AL = character
          ;
          ;
          ; https://stanislavs.org/helppc/scan_codes.html
          ; https://www.win.tue.nl/~aeb/linux/kbd/scancodes-1.html
    jmp short loc_168
; ---------------------------------------------------------------------------

loc_169:        ; CODE XREF: GFX_SELECT_MENU_sub_9+71j
          ; GFX_SELECT_MENU_sub_9+80j ...
    mov ah, 0
    int 16h   ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
          ; Return: AH = scan code, AL = character
    cmp ah, 3Bh   ; F1 Key scan-code
    jl  short loc_169 ; < F1-Key
    cmp ah, 45h   ; > NumLock (4500 is no F-Key)
    jg  short loc_169
    sub ah, 3Bh   ; -ord(F1 Key)
    cmp ah, 5   ; F6 key?
          ;
          ; ----------
          ;
          ; F1    : 0x3B
          ; F2    : 0x3C
          ; F3    : 0x3D
          ; F4    : 0x3E
          ; F5    : 0x3F
          ; F6    : 0x40
          ; F7    : 0x41
          ; F8    : 0x42
          ; F9    : 0x43
          ; F10   : 0x44
          ; Num Lock: 0x45
    jnb short loc_168 ; Jump if above or equal: only F1-F5 are allowed
    mov al, ah
		lea	bx, grafic_type_supported_table
    xlat
		cmp	al, 0FFh	; grafic type supported? you can press F1-F5
					; even if the grafic type is not supported
					; so we	need to	re-check here
    jz  short loc_169
    xor ah, ah
		mov	cs:IN_MAIN_MENU_selected_gfx_index, ax
    stc
    retn
GFX_SELECT_MENU_sub_9 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================


read_config_and_resize_memory proc near ; CODE XREF: start_0+22p
    push  ds
    mov ax, cs
    mov ds, ax
		mov	dx, offset config_tat_filename ; "Config.tat"
    mov ah, 3Dh
    mov al, 0
    int 21h   ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
          ; DS:DX -> ASCIZ filename
          ; AL = access mode
          ; 0 - read
		jb	short loc_816
    mov bx, ax
		mov	dx, offset config_tat_buffer ; overwrites many of the initialization routines (code)
          ; and some other temporary values
          ; good old dirty memory saving style
		mov	cx, 65535	; read max bytes
    mov ah, 3Fh
    int 21h   ; DOS - 2+ - READ FROM FILE WITH HANDLE
          ; BX = file handle, CX = number of bytes to read
          ; DS:DX -> buffer
		jnb	short loc_817	; --> ax = 233h	= 563 bytes

loc_816:				; CODE XREF: read_config_and_resize_memory+Ej
IFDEF DIRECT_START
  ; just exit on error
  patch4_begin:
    mov dx,offset error4
    mov ah,09h
    int 21h
    jmp just_exit  
  patch4_end:    
  ;----
  ; keep all the offsets around intact
  patch4_size = patch4_end - patch4_begin
  patch4_rest_nops = 13 - patch4_size
  IF patch4_rest_nops LT 0
    .ERR <patch4 code too big>
  ENDIF
  db patch4_rest_nops dup(NOOP) ; nops
  ;----
ELSE
    lea ax, program_load_problem_msg_info ; error msg desription
    mov cx, 3   ; seems_unused1_@
    xor dx, dx    ; seems_unused2_@
		call	SOME_PRINTING_show_msg_box_sub_13
    stc     ; CF = 1 -> error
ENDIF    
    pop ds
    retn
; ---------------------------------------------------------------------------

loc_817:				; CODE XREF: read_config_and_resize_memory+1Cj
    mov cs:config_tat_size, ax
		add	ax, offset config_tat_buffer
		mov	cs:maybe_exe_buffer.ofs, ax ; targets the_overwrite_buffer_begin + filesize("config.tat")
		mov	cs:maybe_exe_buffer.segm, cs ; segment
    mov ah, 3Eh
    int 21h   ; DOS - 2+ - CLOSE A FILE WITH HANDLE
          ; BX = file handle
          ;
          ;
          ;
          ;
          ; word_78 = offset the_overwrite_buffer_begin + *(word*)&the_overwrite_buffer_begin[0]
          ; word_79 = offset the_overwrite_buffer_begin + *(word*)&the_overwrite_buffer_begin[2]
          ; word_79 = offset the_overwrite_buffer_begin + *(word*)&the_overwrite_buffer_begin[4]
          ; word_326 = offset the_overwrite_buffer_begin + *(word*)&the_overwrite_buffer_begin[6]
          ; word_81 = offset the_overwrite_buffer_begin + *(word*)&the_overwrite_buffer_begin[8]
		mov	bx, offset config_tat_buffer ; ----------
					;
					; get the 5 offsets in head of config.tat
					;
					; -----------
    mov ax, cs:[bx] ; 0x0E
		add	ax, offset config_tat_buffer
		mov	cs:config_tat_gfx_table_offset,	ax
    add bx, 2
    mov ax, cs:[bx] ; 0x1FD
		add	ax, offset config_tat_buffer
		mov	cs:config_tat_game_name_string,	ax
    add bx, 2
    mov ax, cs:[bx] ; 0x21E
		add	ax, offset config_tat_buffer
		mov	cs:config_tat_publisher_string,	ax
    add bx, 2
    mov ax, cs:[bx] ; 0x209
		add	ax, offset config_tat_buffer
		mov	cs:config_tat_disk_name_string,	ax
    add bx, 2
    mov ax, cs:[bx] ; 0x233
		add	ax, offset config_tat_buffer
		mov	cs:config_tat_content_end, ax
		les	bx, dword ptr cs:maybe_exe_buffer.ofs ;	es=ds=cs, bx = 1BEBh = 19B8h+233h
    shr bx, 1   ; shr bx,4 => bx / 16
    shr bx, 1
    shr bx, 1
    shr bx, 1
		inc	bx		; align	exe_buffer.offset to Paragraphs
					; bx = (bx / 16) + 1 =>	1BFh
    mov ah, 4Ah
    int 21h   ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
          ; ES = segment address of block to change
          ; BX = new size in paragraphs
    mov ah, 48h
    mov bx, 0FFFFh  ; maximum available
    int 21h   ; DOS - 2+ - ALLOCATE MEMORY
          ; BX = number of 16-byte paragraphs desired
          ;
          ; CF gets set -> Error
          ; ax = 8 --> insufficient memory
          ; block will as large as possible
          ;
          ; bx = new size in paragraphs, with my DOSBOX = 9C62h paragraphs
    mov si, 0
    cmp bx, 4000h
    jb  short loc_170
    mov si, 4000h
    cmp bx, 6000h
    jb  short loc_170
    mov si, 8000h
    cmp bx, 8000h
    jb  short loc_170
		mov	si, 0C000h	; <-- we've got way enough memory ; 49152 = 0xC000
					;
					; -------------------
					;
					; bx = allocated dos paragraphs
					; si = 0;
					; if(bx	< 0x4000) goto loc_170;
					; // >=	0x4000
					; si = 0x4000;	  // 0b0100000000000000
					; if(bx	< 0x6000) goto loc_170;
					; // >=	0x6000
					; si = 0x8000;	  // 0b1000000000000000
					; if(bx	< 0x8000) goto loc_170;
					; // >=	0x8000
					; si = 0xC000;	  // 0b1100000000000000
					;
					; loc_170:
					;   si |= 1;	  // 0bxx00000000000001
					;   ax = some_feature_flags;
					;   ax &= 0x3001; // 0b0011000000000001	// clear bits 1-11 and 14+15
					;   si |= ax; // get current flags into	si
					;   some_feature_flags = si; //	set flags
					;
					; ----
					;
					; // 0b0011000000000001
					; //   clear bits 1-11 and 14+15
					; //   keep 1 and 12+13
					; some_feature_flags &=	0x3001;
					; size_type =
					;   (bx	>= 0x8000) ? 3
					;   : (bx >= 0x6000) ? 2
					;   : (bx >= 0x4000) ? 1
					;   : 0;
					; // set size_type in 14+15
					; // set first bit
					; some_feature_flags |=	((size_type << 14) + 1);
					;
					; -------------------

loc_170:        ; CODE XREF: read_config_and_resize_memory+A2j
          ; read_config_and_resize_memory+ABj ...
    or  si, 1   ; -> C001h
		mov	ax, cs:some_feature_flags ; ax = 1
		and	ax, 3001h	; 0b0011000000000001
    or  si, ax
		mov	cs:some_feature_flags, si ; some_feature_flags = C001
    pop ds
    retn      ; CF still 0 - No Error
read_config_and_resize_memory endp


; =============== S U B R O U T I N E =======================================

interrupt_0x97	proc far		; DATA XREF: set_interrupt_vectors_0x97_and_0x24+2o
    nop
    nop
		nop			; <-- set_interrupt_vectors_0x97_and_0x24 points here (optional+1)
					;
					; this or the next nop
					;
					; leaves some space for	something/aligment???
					;
					;
					; -------
    nop
		mov	ax, cs:some_feature_flags
    iret
interrupt_0x97	endp

; ---------------------------------------------------------------------------
; START OF FUNCTION CHUNK FOR start_0

IFNDEF CLEANUP
IFDEF DIRECT_START
    db 6 dup(EMPTY) ; nops
ELSE    
select_gfx:       ; CODE XREF: start_0+82j
          ; DATA XREF: seg000:01D9o
    call  GFX_SELECT_MENU_sub_9
		jmp	main_menu_screen
ENDIF
ENDIF
    
; ---------------------------------------------------------------------------

some_loading_msg_some_PPI_action_and_back_to_main_menu:	; CODE XREF: start_0+308j
          ; start_0+322j
IFDEF DIRECT_START
  ; just exit on error
  patch5_begin:
    mov dx,offset error5
    mov ah,09h
    int 21h
    jmp just_exit  
  patch5_end:    
  ;----
  ; keep all the offsets around intact
  patch5_size = patch5_end - patch5_begin
  patch5_rest_nops = 12 - patch5_size
  IF patch5_rest_nops LT 0
    .ERR <patch5 code too big>
  ENDIF
  db patch5_rest_nops dup(NOOP) ; nops
  ;----
ELSE          
    lea ax, program_load_problem_msg_info ; text_offset_@
    mov cx, 3   ; seems_unused1_@
    xor dx, dx    ; seems_unused2_@
		call	SOME_PRINTING_show_msg_box_sub_13
ENDIF    
    cli
    in  al, 61h   ; PC/XT PPI port B bits:
					; 0: Tmr 2 gate	ÍËÍ OR	03H=spkr ON
					; 1: Tmr 2 data	Í¼  AND	0fcH=spkr OFF
          ; 3: 1=read high switches
          ; 4: 0=enable RAM parity checking
          ; 5: 0=enable I/O channel check
          ; 6: 0=hold keyboard clock low
          ; 7: 0=enable kbrd
    and al, 0FCh
    out 61h, al   ; PC/XT PPI port B bits:
					; 0: Tmr 2 gate	ÍËÍ OR	03H=spkr ON
					; 1: Tmr 2 data	Í¼  AND	0fcH=spkr OFF
          ; 3: 1=read high switches
          ; 4: 0=enable RAM parity checking
          ; 5: 0=enable I/O channel check
          ; 6: 0=hold keyboard clock low
          ; 7: 0=enable kbrd
		jmp	main_menu_screen ; on exit to DOS (but seems to	be not always)
; ---------------------------------------------------------------------------

start_game:       ; CODE XREF: start_0+82j
          ; DATA XREF: seg000:main_menu_jump_tableo
    
IFDEF DIRECT_START    
  patch3_begin:

IF 0  
    mov bx,GFX
ELSE
    mov bx,gfx_mode
ENDIF    

  patch3_end:
  
  ;----
  ; keep all the offsets around intact
  patch3_size = patch3_end - patch3_begin
  patch3_rest_nops = 5 - patch3_size
  IF patch3_rest_nops LT 0
    .ERR <patch3 code too big>
  ENDIF
  db patch3_rest_nops dup(NOOP) ; nops
  ;----
ELSE 
		mov	bx, cs:IN_MAIN_MENU_selected_gfx_index
ENDIF    
    
    push  ds
    push  ax
    xor ax, ax
    mov ds, ax
    assume ds:nothing
    mov ax, bx
    mov ds:(9Fh*sizeof ptr16), ax ; Interrupt[9F]
    pop ax
    pop ds
    assume ds:seg000
    shl bx, 1   ; gfx-index*2
		add	bx, cs:config_tat_gfx_table_offset
    mov bx, cs:[bx]
    or  bx, bx
		jz	short cancel_game_start
		add	bx, offset config_tat_buffer
IFDEF DIRECT_START    
    db 5 dup(NOOP) ; no re-check, the game will just start
ELSE
		call	START_GAME_IS_GFX_SUPPORTED_sub_12 ; CF	is set if game start is	cancelt	due to not supported gfx type
					;
					; preserves bx
		jb	short cancel_game_start	; if(CF) goto cancel_game_start
ENDIF    

loc_173:        ; CODE XREF: start_0+30Dj start_0+34Ej
		call	START_GAME_sub_11 ; ------------
					;
					; very strange construct with START_GAME_sub_11
					; (calling START_GAME_sub_22 itself) and
					; the freestanding START_GAME_sub_22
					; some sort of statemachine?
					;
					; and interrupt	0x97/0x24 gets set severals times the same?
					;
					; POSSIBLE REASON: the game-code was splitted to multiple floppies with	smaller	sized floppies
					; grafixs,sound,music etc.
					;
					; ANOTHER REASON:
					; Intro	code is	splitted from the real game
					;
					; 4 times at this point	before start
					;
					; CF is	set on error
					;
					; ------------
		jb	short cancel_game_start
		mov	al, cs:[bx+gfx_block_t.byte_13h] ; 50h from the	GFX-Block[19]
    and al, 7
		cmp	al, 0		; BLOCK	1?
		jnz	short all_parts_available ; not	taken with 0x50, but with 0x91
					;
					;     0x50=0b01010000
					;     0x91=0b10010001
					; and 0x20=0b00100000
					; and 0x07=0b00000111
		call	START_GAME_sub_22
		jb	short some_loading_msg_some_PPI_action_and_back_to_main_menu
		add	bx, size gfx_block_t
    jmp short loc_173
; ---------------------------------------------------------------------------

all_parts_available:			; CODE XREF: start_0+303j start_0+335j
		push	bx		;
					;
					; ----------------
					;
					;
					;
					; this code gets only runned one time
					;
					;
					; -----------------

before_and_after_game_run:		; CODE XREF: start_0+327j
		call	START_GAME_sub_11 ; come through before	game start and after game ends
		jb	short after_game_run
		mov	al, cs:[bx+gfx_block_t.byte_13h]
    and al, 7
		cmp	al, 1		; BLOCK	2?
		jnz	short after_game_run
		call	START_GAME_sub_22 ; !!!!! starts the game (after some iterations) - multipe sub_22 calls before
		jb	short some_loading_msg_some_PPI_action_and_back_to_main_menu
		add	bx, size gfx_block_t ; next gfx-block
		jmp	short before_and_after_game_run
; ---------------------------------------------------------------------------

after_game_run:				; CODE XREF: start_0+313j start_0+31Dj
    pop ax
    xchg  ax, bx
    xor cx, cx
    mov es, cx
    assume es:nothing
		cmp	cs:subprogram_exit_code, 0FFh ;	game subprocess	return code?
		jnz	short all_parts_available
		call	START_GAME_sub_11
		jb	short back_to_menu
    mov al, cs:[bx+13h]
    and al, 7
		cmp	al, 2		; BLOCK	3?
		jnz	short cancel_game_start
		call	START_GAME_sub_22
		jb	short cancel_game_start
    add bx, 18h
    jmp short loc_173
; ---------------------------------------------------------------------------

cancel_game_start:			; CODE XREF: start_0+2EBj start_0+2F4j ...
		or	cs:some_feature_flags, 1

back_to_menu:				; CODE XREF: start_0+33Aj

IFDEF DIRECT_START          
    jmp shutdown_cleanup
ELSE
    jmp	main_menu_screen ; !!! on exit in game (not exit to DOS	in text	menu)
ENDIF    
    
; END OF FUNCTION CHUNK FOR start_0

; =============== S U B R O U T I N E =======================================


START_GAME_sub_11 proc near		; CODE XREF: start_0:loc_173p
					; start_0:before_and_after_game_runp ...
		cmp	cs:[bx+gfx_block_t.filename], 0FFh ; GFX-Block[GFX][0] == 0xFF?
		jz	short is_end_block ; starting with 0xFF
		test	cs:[bx+gfx_block_t.byte_13h], 20h ; -----
					;
					; if((cs:[bx+19] & 0b00100000) == 0)
					; 0x50 & 0x20 =	0
					; 0x91 & 0x20 =	0
					;
					; ----
		jz	short is_useable_block
		call	START_GAME_sub_22
		jb	short cancel_game_start
		add	bx, size gfx_block_t ; sizeof(GFX-Block) == 18h
		jmp	short START_GAME_sub_11
; ---------------------------------------------------------------------------

is_useable_block:			; CODE XREF: START_GAME_sub_11+Bj
    clc
    retn
; ---------------------------------------------------------------------------

is_end_block:				; CODE XREF: START_GAME_sub_11+4j
    stc
    retn
START_GAME_sub_11    endp


; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 84h dup(EMPTY)
ELSE

START_GAME_IS_GFX_SUPPORTED_sub_12 proc	near ; CODE XREF: start_0+2F1p
		push	bx		; bx = offset to config.tat gfx[GXF]-block
		mov	ax, cs:word_752
		mov	al, [bx+gfx_block_t.byte_14h] ;	low reg	al gets	overwritten (so	word_752+1) is unused here
    mov si, ax
    and si, 0FFh
		mov	al, cs:gfx_type_array[si]
		mov	cx, ax		; cx = 0505h with VGA
		cmp	si, 2		; is si	== GFX:TANDY
    jnz short loc_622
		test	ah, 40h		; is bit[7] (tandy) set?
    jnz short loc_92
		jmp	short not_supported
; ---------------------------------------------------------------------------
		nop

loc_622:				; CODE XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+18j
		cmp	ah, al		; 05h == 05h with GFX:VGA
		jnb	short loc_92	; taken	with GFX:VGA (==JNAE: Jump if above or equal)
		jmp	short not_supported
; ---------------------------------------------------------------------------

loc_92:					; CODE XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+1Dj
					; START_GAME_IS_GFX_SUPPORTED_sub_12+24j
		mov	ax, cs:word_752	; ax = 0505h with GFX:VGA
		cmp	al, cs:gfx_type_array2[si] ; low reg al	is used	here, si = GFX:VGA(4), gfx_type_array2[4]=5
		jnb	short success

not_supported:				; CODE XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+1Fj
					; START_GAME_IS_GFX_SUPPORTED_sub_12+26j
    mov bp, bx
    xor bx, bx
    mov dx, cx
    shl si, 1
		mov	bx, cs:gfx_string_offset_table[si]
    mov cx, 8
    mov ax, cs
    mov es, ax
    assume es:seg000
    mov ds, ax
    mov si, bx
    mov al, 6Eh
		cmp	byte ptr [bx], 45h ; bx	targets	what?
    jz  short loc_624
    mov al, 20h

loc_624:				; CODE XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+50j
    mov cs:text_problem3, al
		lea	di, text_gfx_not_supported
    rep movsb
    mov si, bx
		lea	di, text_esc_or_space_message
    mov cx, 8
    rep movsb
    xor dx, dx    ; seems_unused2_@
		mov	word ptr cs:IN_MAIN_MENU_selected_gfx_index, 0FFFFh
		lea	ax, text_problem ; text_offset_@
    mov cx, 5   ; seems_unused1_@
		call	SOME_PRINTING_show_msg_box_sub_13
		jz	short error	; ESC key pressed -> cancel game start,	anyother key = still try to start the game (alternative	if the gfx detection was not correct)

success:				; CODE XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+31j
    pop bx
		clc			; CF = 0 - let try starting the	game
    retn
; ---------------------------------------------------------------------------

error:					; CODE XREF: START_GAME_IS_GFX_SUPPORTED_sub_12+7Cj
    pop bx
		stc			; CF = 1 - starting canceled
    retn
START_GAME_IS_GFX_SUPPORTED_sub_12 endp

ENDIF
ENDIF

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 6 dup(EMPTY) ; nops
ELSE
; =============== S U B	R O U T	I N E =======================================
; no caller?
;
; dead code?
;
;
JOYSTICK_CALIBRATION proc near
		call	JOYSTICK_STUFF_sub_29
		jmp	main_menu_screen
JOYSTICK_CALIBRATION endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 1ah dup(EMPTY)
ELSE

; void __usercall SOME_PRINTING_show_msg_box_sub_13(__int16 text_offset_@<ax>, __int16 seems_unused1_@<cx>, __int16 seems_unused2_@<dx>)
SOME_PRINTING_show_msg_box_sub_13 proc near ; CODE XREF: read_config_and_resize_memory+27p
          ; start_0+2C0p ...
    push  bx
    call  SOME_PRINTING_THREE_sub_14
    mov dx, 0B09h ; y_@
    lea ax, press_a_key_text ; text_offset_@ "Press a key"
    call  SOME_PRINTING_sub_18
    call  wait_key_check_esc
    pushf
    push  ax
    call  SOME_PRINTING_TWO_sub_17
    pop ax
    popf
    pop bx
    retn
SOME_PRINTING_show_msg_box_sub_13 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 3fh dup(EMPTY)
ELSE

SOME_PRINTING_THREE_sub_14 proc	near	; CODE XREF: SOME_PRINTING_show_msg_box_sub_13+1p
					; JOYSTICK_STUFF2_sub_30+25p ...
    cld
    push  dx
    push  ax
    call  init_video_mode_and_cursor
    call  SOME_PRINTING_TWO_sub_17
    mov al, 3
    mov cs:text_y_offset, al
    mov al, 10h
    mov cs:text_x_offset, al
    xor dx, dx    ; y_@
    lea ax, byte_631  ; text_offset_@
    call  SOME_PRINTING_sub_18
    add dh, 4   ; y_@
    lea ax, byte_632  ; text_offset_@

loc_633:        ; CODE XREF: SOME_PRINTING_THREE_sub_14+2Aj
    call  SOME_PRINTING_sub_18
    inc dh    ; y_@
    loop  loc_633
    lea ax, byte_634  ; text_offset_@
    call  SOME_PRINTING_sub_18
    mov al, 13h
    mov cs:text_x_offset, al
    pop ax    ; text_offset_@
    pop dx    ; y_@
    call  SOME_PRINTING_sub_18
    retn
SOME_PRINTING_THREE_sub_14 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 1Dh dup(EMPTY)
ELSE

init_video_mode_and_cursor proc near  ; CODE XREF: SOME_PRINTING_THREE_sub_14+3p
					; START_GAME_sub_22+12p ...
    push  bx
    push  ax
    push  cx
    mov ah, 0
    mov al, 2   ; http://vitaly_filatov.tripod.com/ng/asm/asm_023.1.html
          ; 02h
          ; Text
          ; 80x25
          ; All but MDA
          ; 16 gray
          ; B8000
    int 10h   ; - VIDEO - SET VIDEO MODE
          ; AL = mode
    mov ah, 2
    xor bx, bx    ; page = 0; not neeeded
    mov dx, 8181h ; dh=81h, dl=81h = 129??
    int 10h   ; - VIDEO - SET CURSOR POSITION
          ; DH,DL = row, column (0,0 = upper left)
          ; BH = page number
    mov ah, 1
    mov cx, 201Fh
    int 10h   ; - VIDEO - SET CURSOR CHARACTERISTICS
          ; CH bits 0-4 = start line for cursor in character cell
          ; bits 5-6 = blink attribute
          ; CL bits 0-4 = end line for cursor in character cell
    pop cx
    pop ax
    pop bx
    retn
init_video_mode_and_cursor endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 1ah dup(EMPTY)
ELSE

LOADING_MSG_sub_16 proc near    ; CODE XREF: start_0+79p
    push  ax
    call  SOME_PRINTING_TWO_sub_17
    xor dx, dx    ; y_@
    mov al, 0Ah
    mov cs:text_y_offset, al
    mov al, 1Ch
    mov cs:text_x_offset, al
		mov	ax, (offset text_not_enough_memory+2Ch)	; text_offset_@
    call  SOME_PRINTING_sub_18
    pop ax
    retn
LOADING_MSG_sub_16 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 33h dup(EMPTY)
ELSE

SOME_PRINTING_TWO_sub_17 proc near  ; CODE XREF: MAIN_MENU_sub_8p
          ; GFX_SELECT_MENU_sub_9p ...
    push  ax
    push  di
    push  cx
    push  es
		mov	es, cs:text_video_seg
    assume es:nothing
    xor di, di
    mov cx, 1920  ; 80 * (25-1) = 1920 -> 24 lines of 25 getting filled
    mov al, 0B1h  ; https://en.wikipedia.org/wiki/VGA_text_mode
          ;
          ; al = character = 0xB1 -> some ASCII Block
          ; ah = attribute = 7 -> grey forground color (nothing more)
    mov ah, 7
    rep stosw   ; fill text mode memory with word:  ES:[DI...DI+1920]=AX
    xor dx, dx    ; y_@
    mov al, 24
    mov cs:text_y_offset, al
		mov	bx, cs:config_tat_disk_name_string
    mov al, cs:[bx] ; cs:byte_87 = some_offset_word_326[0]
    mov cs:text_x_offset, al
    inc bx
    mov ax, bx    ; maybe_offset_@
          ; offset ax = &some_offset_word_326[1]
    call  SOME_PRINTING_sub_18
    pop es
    pop cx
    pop di
    pop ax
    retn
SOME_PRINTING_TWO_sub_17 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START

  db 81h dup(EMPTY)

ELSE

; void __usercall SOME_PRINTING_sub_18(__int16 text_offset_@<ax>, __int8 x_@<dl>, __int8 y_@<dh>)
SOME_PRINTING_sub_18 proc near    ; CODE XREF: MAIN_MENU_sub_8+48p
          ; GFX_SELECT_MENU_sub_9+15p ...
    push  di
    push  es
    push  ax
    push  cx
    push  dx
    push  si
    push  ds
    

    
    mov si, ax    ; for example: error message offset
    mov ax, cs
    mov ds, ax
		mov	es, cs:text_video_seg

loc_636:        ; CODE XREF: SOME_PRINTING_sub_18+3Fj
    mov al, dh
    add al, cs:text_y_offset
    mov ah, 160   ; (y_offset+y)*160+(x+x_offset)*2
    mul ah
    mov di, ax
    xor ax, ax
    mov al, dl
    add al, cs:text_x_offset
    shl ax, 1
    add di, ax
    mov ah, 7
    mov ch, 20h

loc_186:        ; CODE XREF: SOME_PRINTING_sub_18+48j
          ; SOME_PRINTING_sub_18+50j ...
    lodsb     ; read byte from message
          ; AL = DS:[SI]
    cmp al, '$'         ; like DOS line end
    jz  short loc_187
    or  al, al
    jz  short loc_187
    cmp al, 0Dh
    jnz short loc_635
    inc dh
    jmp short loc_636
; ---------------------------------------------------------------------------

loc_635:        ; CODE XREF: SOME_PRINTING_sub_18+3Bj
    cmp al, 4
    jnz short loc_637
    lodsb
    mov ah, al
    jmp short loc_186
; ---------------------------------------------------------------------------

loc_637:        ; CODE XREF: SOME_PRINTING_sub_18+43j
    cmp al, 5
    jnz short loc_638
    mov ah, 7
    jmp short loc_186
; ---------------------------------------------------------------------------

loc_638:        ; CODE XREF: SOME_PRINTING_sub_18+4Cj
    cmp al, 3
    jnz short loc_639
    lodsb
    xor cx, cx
    mov cl, al
    shl cx, 1
    add di, cx
    jmp short loc_186
; ---------------------------------------------------------------------------

loc_639:        ; CODE XREF: SOME_PRINTING_sub_18+54j
    cmp al, 1
    jz  short loc_186
    cmp al, 2
    jnz short loc_640
    lodsb
    mov cl, al
    mov al, ch
    xor ch, ch
    rep stosw   ; ES:[DI...] = AX
    jmp short loc_186
; ---------------------------------------------------------------------------

loc_640:        ; CODE XREF: SOME_PRINTING_sub_18+67j
    mov ch, al    ; last char
    stosw     ; ES:[DI] = AX
    jmp short loc_186
; ---------------------------------------------------------------------------

loc_187:        ; CODE XREF: SOME_PRINTING_sub_18+33j
          ; SOME_PRINTING_sub_18+37j
    pop ds
    pop si
    pop dx
    pop cx
    pop ax
    pop es
    pop di
    retn
SOME_PRINTING_sub_18 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

; --------------------
;
; gets called 4	times
;
;
; checks if prog1.cc exists
; AND sets 0 at end of progs1.cc filename
;
; --------------------

IFDEF DIRECT_START

patch8_begin:

START_GAME_DOES_FILE_EXIST_sub_19 proc near ; CODE XREF: START_GAME_sub_22+8p
		mov	si, bx		; bx = offset gfx_block.filename

find_first_blank_loop:			; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+9j
		lodsb			; load first char of filename, ++si
    or  al, al
		jz	short found_null_in_name
    cmp al, 20h
		jnz	short find_first_blank_loop
		mov	byte ptr [si-1], 0 ; set filename asciiz 0 at first found 0x20 (blank)

found_null_in_name:

    mov ah, 3Dh
    mov al, 0
    mov si, cs
    mov ds, si
		mov	dx, bx		; bx = offset gfx_block.filename = 'progs.cc1'
    int 21h   ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
          ; DS:DX -> ASCIZ filename
          ; AL = access mode
          ; 0 - read
    ; search for data disk if file can't be loaded
    jnb  short file_exists
    
    mov dx,offset error8
    mov ah,09h
    int 21h
    jmp just_exit 
   
    
file_exists:   
    cld ; always return file exists
    retn  

START_GAME_DOES_FILE_EXIST_sub_19 endp

patch8_end:   

IFNDEF CLEANUP
  ;----
  ; keep all the offsets around intact
  patch8_size = patch8_end - patch8_begin
  patch8_rest_nops = 0b3h - patch8_size
  IF patch8_rest_nops LT 0
    .ERR <patch8 code too big>
  ENDIF
  db patch8_rest_nops dup(EMPTY) ; nops
  ;----  
ENDIF

ELSE

START_GAME_DOES_FILE_EXIST_sub_19 proc near ; CODE XREF: START_GAME_sub_22+8p
                mov     si, bx          ; bx = offset gfx_block.filename

find_first_blank_loop:                  ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+9j
                lodsb                   ; load first char of filename, ++si
                or      al, al
                jz      short found_null_in_name
                cmp     al, 20h
                jnz     short find_first_blank_loop
                mov     byte ptr [si-1], 0 ; set filename asciiz 0 at first found 0x20 (blank)

found_null_in_name:                     ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+5j
                push    bx
                mov     ah, 19h
                int     21h             ; DOS - GET DEFAULT DISK NUMBER
                mov     cs:current_dos_drive, al

loc_649:                                ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+A4j
                mov     ah, 3Dh
                mov     al, 0
                mov     si, cs
                mov     ds, si
                mov     dx, bx          ; bx = offset gfx_block.filename = 'progs.cc1'
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read
                                        ;
                                        ; AX = filehandle
                jb      short loc_643
                jmp     short file_exists
; ---------------------------------------------------------------------------
                nop

loc_643:                                ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+24j
                mov     dl, 0
                mov     ah, 0Eh
                int     21h             ; DOS - SELECT DISK
                                        ; DL = new default drive number (0 = A, 1 = B, etc.)
                                        ; Return: AL = number of logical drives
                mov     ah, 3Dh
                mov     al, 0
                mov     si, cs
                mov     ds, si
                mov     dx, bx
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read
                jnb     short file_exists
                int     11h             ; EQUIPMENT DETERMINATION
                                        ; Return: AX = equipment flag bits
                and     ax, 0C0h
                jz      short loc_644
                mov     dl, 1
                mov     ah, 0Eh
                int     21h             ; DOS - SELECT DISK
                                        ; DL = new default drive number (0 = A, 1 = B, etc.)
                                        ; Return: AL = number of logical drives
                mov     ah, 3Dh
                mov     al, 0
                mov     si, cs
                mov     ds, si
                mov     dx, bx
                int     21h             ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
                                        ; DS:DX -> ASCIZ filename
                                        ; AL = access mode
                                        ; 0 - read
                jnb     short file_exists

loc_644:                                ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+42j
                pop     bx
                push    bx
                mov     dl, cs:current_dos_drive
                mov     ah, 0Eh
                int     21h             ; DOS - SELECT DISK
                                        ; DL = new default drive number (0 = A, 1 = B, etc.)
                                        ; Return: AL = number of logical drives
                xor     ax, ax
                mov     al, cs:[bx+15h]
                mov     si, ax
                shl     si, 1
                add     si, cs:config_tat_publisher_string
                mov     si, cs:[si]
                add     si, offset config_tat_buffer
                mov     ax, cs
                mov     es, ax
                assume es:seg000
                mov     ds, ax
                lea     di, text_drive_name_placeholder
                mov     cx, 20h
                mov     al, 1
                rep stosb
                lea     di, text_drive_name_placeholder

loc_646:                                ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+94j
                lodsb
                or      al, al
                jz      short loc_645
                stosb
                jmp     short loc_646
; ---------------------------------------------------------------------------

loc_645:                                ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+91j
                xor     dx, dx          ; seems_unused2_@
                mov     cx, 3           ; seems_unused1_@
                lea     ax, change_insert_disk_text ; text_offset_@ "Change insert disk ..."
                call    SOME_PRINTING_show_msg_box_sub_13
                jz      short file_does_not_exists
                jmp     loc_649
; ---------------------------------------------------------------------------

file_exists:                            ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+26j
                                        ; START_GAME_DOES_FILE_EXIST_sub_19+3Bj ...
                mov     bx, ax
                mov     ah, 3Eh
                int     21h             ; DOS - 2+ - CLOSE A FILE WITH HANDLE
                                        ; BX = file handle
                cld
                pop     bx
                retn
; ---------------------------------------------------------------------------

file_does_not_exists:                   ; CODE XREF: START_GAME_DOES_FILE_EXIST_sub_19+A2j
                stc
                pop     bx
                retn
START_GAME_DOES_FILE_EXIST_sub_19 endp

ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 20h dup(EMPTY)
ELSE

WAIT_F_KEY_sub_20 proc near   ; CODE XREF: start_0:wait_key_loc_604p
          ; WAIT_F_KEY_sub_20+Aj ...
    mov ah, 1
    int 16h   ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
          ; Return: ZF clear if character in buffer
          ; AH = scan code, AL = character
          ; ZF set if no character in buffer
    jz  short loc_650
    xor ah, ah
    int 16h   ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
          ; Return: AH = scan code, AL = character
    jmp short WAIT_F_KEY_sub_20
; ---------------------------------------------------------------------------

loc_650:        ; CODE XREF: WAIT_F_KEY_sub_20+4j
    mov ah, 0
    int 16h   ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
          ; Return: AH = scan code, AL = character
    cmp ah, 3Bh   ; F1-Key
    jl  short WAIT_F_KEY_sub_20
    cmp ah, 45h   ; https://sites.google.com/site/pcdosretro/scancodes
          ;
          ; Num Lock?
    jg  short WAIT_F_KEY_sub_20
    sub ah, 3Bh   ; F1-Key
          ;
          ; F1-F10: 0x3B-0x44
          ; Num Lock 0x45
          ;
          ; ---
          ;
          ; do
          ; {
          ;   scan_code = wait_key();
          ; }
          ; while(scan_code < F1 || scan_code > NumLock)
          ; nr = scan_code - F1;
          ;
          ; nr ==> 0-4
    mov al, ah
    retn
WAIT_F_KEY_sub_20 endp

ENDIF
ENDIF

; ---------------------------------------------------------------------------
; START	OF FUNCTION CHUNK FOR START_GAME_FEATURE_FLAG_STUFF_sub_21

loc_203:				; CODE XREF: START_GAME_FEATURE_FLAG_STUFF_sub_21+17j
          ; DATA XREF: seg000:154Co
    cmp ax, cx
    ja  short loc_204
    stc
    retn
; ---------------------------------------------------------------------------

loc_205:				; CODE XREF: START_GAME_FEATURE_FLAG_STUFF_sub_21+17j
          ; DATA XREF: seg000:154Eo ...
    cmp ax, cx
    ja  short loc_204
    stc
    retn
; ---------------------------------------------------------------------------

loc_204:				; CODE XREF: START_GAME_FEATURE_FLAG_STUFF_sub_21-31j
					; START_GAME_FEATURE_FLAG_STUFF_sub_21-2Bj
    clc
    retn
; ---------------------------------------------------------------------------

loc_206:				; CODE XREF: START_GAME_FEATURE_FLAG_STUFF_sub_21+17j
					; DATA XREF: seg000:jump_table_off_653o
    cmp ax, cx
    jb  short loc_651
IFDEF DIRECT_START
  ; just exit on error
  patch6_begin:
    mov dx,offset error6
    mov ah,09h
    int 21h
    jmp just_exit 
  patch6_end:    
  ;----
  ; keep all the offsets around intact
  patch6_size = patch6_end - patch6_begin
  patch6_rest_nops = 12 - patch6_size
  IF patch6_rest_nops LT 0
    .ERR <patch6 code too big>
  ENDIF
  db patch6_rest_nops dup(NOOP) ; nops
  ;----
ELSE    
		lea	ax, text_not_enough_memory ; text_offset_@
    mov cx, 1   ; seems_unused1_@
    xor dx, dx    ; seems_unused2_@
		call	SOME_PRINTING_show_msg_box_sub_13
ENDIF    
    cli
    in  al, 61h   ; PC/XT PPI port B bits:
					; 0: Tmr 2 gate	ÍËÍ OR	03H=spkr ON
					; 1: Tmr 2 data	Í¼  AND	0fcH=spkr OFF
          ; 3: 1=read high switches
          ; 4: 0=enable RAM parity checking
          ; 5: 0=enable I/O channel check
          ; 6: 0=hold keyboard clock low
          ; 7: 0=enable kbrd
    and al, 0FCh
    out 61h, al   ; PC/XT PPI port B bits:
					; 0: Tmr 2 gate	ÍËÍ OR	03H=spkr ON
					; 1: Tmr 2 data	Í¼  AND	0fcH=spkr OFF
          ; 3: 1=read high switches
          ; 4: 0=enable RAM parity checking
          ; 5: 0=enable I/O channel check
          ; 6: 0=hold keyboard clock low
          ; 7: 0=enable kbrd
    sti
		jmp	main_menu_screen
; ---------------------------------------------------------------------------

loc_651:				; CODE XREF: START_GAME_FEATURE_FLAG_STUFF_sub_21-23j
    stc
    retn
; END OF FUNCTION CHUNK	FOR START_GAME_FEATURE_FLAG_STUFF_sub_21
; ---------------------------------------------------------------------------
jump_table_off_653 dw offset loc_206	; DATA XREF: START_GAME_FEATURE_FLAG_STUFF_sub_21+17r
    dw offset loc_203
    dw offset loc_205
    dw offset loc_205

; =============== S U B R O U T I N E =======================================


START_GAME_FEATURE_FLAG_STUFF_sub_21 proc near ; CODE XREF: START_GAME_sub_22+3p

; FUNCTION CHUNK AT 151F SIZE 0000002B BYTES

		mov	si, cs:[bx+gfx_block_t.word_16h]
		mov	ax, si		; always 0
		and	ax, 0F000h	; 0xF000 = 0b1111000000000000
		mov	cx, cs:some_feature_flags
		and	cx, 0F000h	; 0xF000 = 0b1111000000000000
		and	si, 3		; 0x0003 = 0b0000000000000011
		shl	si, 1		; si *=	2
		jmp	cs:jump_table_off_653[si] ; always si =	0
START_GAME_FEATURE_FLAG_STUFF_sub_21 endp


; =============== S U B R O U T I N E =======================================


START_GAME_sub_22 proc near		; CODE XREF: start_0+305p start_0+31Fp ...
		call	set_interrupt_vectors_0x97_and_0x24 ; -------
					;
					;
					;
					; set serveral times? just stupid but ok
					;
					;
					;
					;
					; ---------------
		call	START_GAME_FEATURE_FLAG_STUFF_sub_21
		jnb	short locret_654 ; if(!CF)...
		call	START_GAME_DOES_FILE_EXIST_sub_19
		jnb	short loc_655	; if(!CF)... CF	set on file exists

locret_654:				; CODE XREF: START_GAME_sub_22+6j
    retn
; ---------------------------------------------------------------------------

loc_655:				; CODE XREF: START_GAME_sub_22+Bj
		call	GAME_START_sub_7 ; starts the game code
					; gets also called several times
    pushf
IFDEF DIRECT_START    
    db 3 dup(NOOP)
ELSE
    call  init_video_mode_and_cursor
ENDIF    
    popf
    retn
START_GAME_sub_22 endp


; =============== S U B R O U T I N E =======================================

interrupt_0x24	proc far		; DATA XREF: set_interrupt_vectors_0x97_and_0x24+12o
    cmp cs:dos_version, 3
		jb	short below_DOS_3 ; < DOS 3?
    mov al, 3
    iret
; ---------------------------------------------------------------------------

below_DOS_3:				; CODE XREF: interrupt_0x24+6j
    pop ax
    pop ax
    pop ax
    pop ax
    pop bx
    pop cx
    pop dx
    pop si
    pop di
    mov bp, sp
    or  word ptr [bp+0Ah], 1
    pop bp
    pop ds
    pop es
    assume es:nothing
    iret
interrupt_0x24	endp ; sp-analysis failed


; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  db 8 dup(EMPTY)
ELSE

wait_key_check_esc proc	near		; CODE XREF: SOME_PRINTING_show_msg_box_sub_13+Ep
    mov ah, 0
    int 16h   ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
          ; Return: AH = scan code, AL = character
		cmp	ax, 11Bh	; Esc -	or other to proceed
    retn
wait_key_check_esc endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================

IFNDEF CLEANUP
IFDEF DIRECT_START
  ; remove joystick detection dead code
  db 1F5h dup(EMPTY) ; nops
ELSE

JOYSTICK_STUFF_sub_29 proc near		; CODE XREF: JOYSTICK_CALIBRATIONp
		and	cs:some_feature_flags, 0EFFFh ;	0b1110111111111111
					;
					; bit[12] = joystick detected =	0 = not	detected
		call	CALIBRATE_JOYSTICK_STUFF_sub_31
		jb	short no_joystick_detected ; jump if carry set
		call	JOYSTICK_STUFF2_sub_30
    jb  short locret_658
		or	cs:some_feature_flags, 1000h ;	0b0001000000000000
					;
					; bit[12] = joystick detected

locret_658:				; CODE XREF: JOYSTICK_STUFF_sub_29+Fj
    retn
; ---------------------------------------------------------------------------

no_joystick_detected:			; CODE XREF: JOYSTICK_STUFF_sub_29+Aj
    xor dx, dx    ; seems_unused2_@
		lea	ax, text_no_joystick_card_detected ; text_offset_@
    mov cx, 2   ; seems_unused1_@
		call	SOME_PRINTING_show_msg_box_sub_13
    retn
JOYSTICK_STUFF_sub_29 endp


; =============== S U B R O U T I N E =======================================


JOYSTICK_STUFF2_sub_30 proc near	; CODE XREF: JOYSTICK_STUFF_sub_29+Cp
    push  es
    push  di
    cld
    xor ax, ax
    mov es, ax
    assume es:nothing
    mov cs:byte_56, 0FFh
    mov di, 260h
    stosw
    stosw
    mov di, 264h
    stosw
    stosw
    mov di, 268h
    stosw
    stosw
    xor dx, dx
		lea	ax, text_joystick_calibration
    mov cx, 5
    call  SOME_PRINTING_THREE_sub_14
    mov al, 23h
    mov cs:text_x_offset, al
    mov al, 12h
    mov cs:text_y_offset, al
    mov dx, 0   ; y_@
    mov al, 0DFh
    mov cs:byte_378, al
    mov al, 20h
    mov cs:byte_377, al
    mov cs:byte_376, al
		lea	ax, text_joystick_calibrate_success ; text_offset_@
    call  SOME_PRINTING_sub_18

loc_662:				; CODE XREF: JOYSTICK_STUFF2_sub_30+58j
		call	CALIBRATE_JOYSTICK_STUFF_sub_31
    jnb short loc_661
    jmp loc_214
; ---------------------------------------------------------------------------

loc_661:				; CODE XREF: JOYSTICK_STUFF2_sub_30+51j
    or  bl, bl
    jz  short loc_662
    push  ds
    xor bx, bx
    mov ds, bx
    assume ds:nothing
    mov bx, 264h
    mov [bx], si
    mov [bx+2], di
    pop ds
    assume ds:seg000
    mov dx, 0   ; y_@
    mov al, 0DBh
    mov cs:byte_376, al
    mov al, 20h
    mov cs:byte_377, al
    mov cs:byte_378, al
		lea	ax, text_joystick_calibrate_success ; text_offset_@
    call  SOME_PRINTING_sub_18
		lea	ax, text_joystick_calibrate_success ; text_offset_@
    call  SOME_PRINTING_sub_18

loc_664:				; CODE XREF: JOYSTICK_STUFF2_sub_30+93j
		call	CALIBRATE_JOYSTICK_STUFF_sub_31
    jnb short loc_663
    jmp short loc_214
; ---------------------------------------------------------------------------
		nop

loc_663:				; CODE XREF: JOYSTICK_STUFF2_sub_30+8Cj
    or  bl, bl
    jz  short loc_664
    push  ds
    xor bx, bx
    mov ds, bx
    assume ds:nothing
    mov bx, 260h
    mov [bx], si
    mov [bx+2], di
    pop ds
    assume ds:seg000
    mov dx, 0   ; y_@
    mov al, 0DCh
    mov cs:byte_377, al
    mov al, 20h
    mov cs:byte_378, al
    mov cs:byte_376, al
		lea	ax, text_joystick_calibrate_success ; text_offset_@
    call  SOME_PRINTING_sub_18
		lea	ax, text_joystick_calibrate_success ; text_offset_@
    call  SOME_PRINTING_sub_18

loc_665:				; CODE XREF: JOYSTICK_STUFF2_sub_30+CBj
		call	CALIBRATE_JOYSTICK_STUFF_sub_31
    jb  short loc_214
    or  bl, bl
    jz  short loc_665
    push  ds
    xor bx, bx
    mov ds, bx
    assume ds:nothing
    mov bx, 268h
    mov [bx], si
    mov [bx+2], di
    mov si, 260h
    mov ax, [si]
    mov bx, [si+2]
    mov cx, [si+4]
    mov dx, [si+6]
    mov di, [si+0Ah]
    mov si, [si+8]
    pop ds
    assume ds:seg000
    cmp cx, ax
    jnb short loc_214
    cmp ax, si
    jnb short loc_214
    cmp dx, bx
    jnb short loc_214
    cmp bx, di
    jnb short loc_214
    jmp short loc_666
; ---------------------------------------------------------------------------

loc_214:				; CODE XREF: JOYSTICK_STUFF2_sub_30+53j
					; JOYSTICK_STUFF2_sub_30+8Ej ...
    mov dx, 0   ; seems_unused2_@
		lea	ax, text_joystick_calibration_error ; text_offset_@
    mov cx, 2   ; seems_unused1_@
		call	SOME_PRINTING_show_msg_box_sub_13
    stc
    pop di
    pop es
    assume es:nothing
    retn
; ---------------------------------------------------------------------------

loc_666:				; CODE XREF: JOYSTICK_STUFF2_sub_30+FFj
    mov dx, 0
		lea	ax, text_joystick_calibrated_success2
    mov cx, 2
    call  SOME_PRINTING_THREE_sub_14

loc_669:				; CODE XREF: JOYSTICK_STUFF2_sub_30+124j
		call	CALIBRATE_JOYSTICK_STUFF_sub_31
    or  bl, bl
    jnz short loc_669

loc_670:				; CODE XREF: JOYSTICK_STUFF2_sub_30+12Bj
		call	CALIBRATE_JOYSTICK_STUFF_sub_31
    or  bl, bl
    jz  short loc_670
    clc
    pop di
    pop es
    retn
JOYSTICK_STUFF2_sub_30 endp


; =============== S U B R O U T I N E =======================================


CALIBRATE_JOYSTICK_STUFF_sub_31	proc near ; CODE XREF: JOYSTICK_STUFF_sub_29+7p
					; JOYSTICK_STUFF2_sub_30:loc_662p ...
		call	DETECT_JOYSTICK_sub_32
    jb  short loc_221
    xor bx, bx
    in  al, dx
    not al
    and al, 30h
    cmp al, cs:byte_56
    jz  short loc_222
    mov cs:byte_56, al
    or  al, al
    jz  short loc_222
    mov cx, 0FFFFh

loc_671:				; CODE XREF: CALIBRATE_JOYSTICK_STUFF_sub_31:loc_671j
    loop  loc_671
    mov bx, 0FFFFh
    clc
    retn
; ---------------------------------------------------------------------------

loc_222:				; CODE XREF: CALIBRATE_JOYSTICK_STUFF_sub_31+11j
					; CALIBRATE_JOYSTICK_STUFF_sub_31+19j
    mov ah, 1
    int 16h   ; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
          ; Return: ZF clear if character in buffer
          ; AH = scan code, AL = character
          ; ZF set if no character in buffer
    mov ax, 0
    jz  short loc_672
    mov ah, 0
    int 16h   ; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
          ; Return: AH = scan code, AL = character
		cmp	al, 1Bh		; ESC key
    jz  short loc_221
    mov ax, 0FFFFh
    mov bx, ax

loc_672:				; CODE XREF: CALIBRATE_JOYSTICK_STUFF_sub_31+2Cj
		clc			; clear	carry flag
    retn
; ---------------------------------------------------------------------------

loc_221:				; CODE XREF: CALIBRATE_JOYSTICK_STUFF_sub_31+3j
					; CALIBRATE_JOYSTICK_STUFF_sub_31+34j
		stc			; set carry flag
    retn
CALIBRATE_JOYSTICK_STUFF_sub_31	endp


; =============== S U B R O U T I N E =======================================


DETECT_JOYSTICK_sub_32 proc near	; CODE XREF: CALIBRATE_JOYSTICK_STUFF_sub_31p
    mov bl, 1
    mov bh, 2
		mov	dx, 201h	; https://wiki.osdev.org/Game_port
    cli
    xor cx, cx

loc_674:				; CODE XREF: DETECT_JOYSTICK_sub_32+11j
    in  al, dx    ; Game I/O port
          ; bits 0-3: Coordinates (resistive, time-dependent inputs)
          ; bits 4-7: Buttons/Triggers (digital inputs)
    jmp short $+2
; ---------------------------------------------------------------------------

loc_673:				; CODE XREF: DETECT_JOYSTICK_sub_32+Bj
    test  al, bl
    jz  short loc_227
    loop  loc_674
    sti
    stc
    retn
; ---------------------------------------------------------------------------

loc_227:				; CODE XREF: DETECT_JOYSTICK_sub_32+Fj
					; DETECT_JOYSTICK_sub_32+1Ej
    out dx, al
    jmp short $+2
; ---------------------------------------------------------------------------

loc_675:				; CODE XREF: DETECT_JOYSTICK_sub_32+17j
    in  al, dx
    jmp short $+2
; ---------------------------------------------------------------------------

loc_676:				; CODE XREF: DETECT_JOYSTICK_sub_32+1Aj
    test  al, bl
    jz  short loc_227
    xor cx, cx

loc_679:				; CODE XREF: DETECT_JOYSTICK_sub_32+29j
    in  al, dx
    jmp short $+2
; ---------------------------------------------------------------------------

loc_677:				; CODE XREF: DETECT_JOYSTICK_sub_32+23j
    test  al, bl
    jz  short loc_678
    loop  loc_679
    sti
    stc
    retn
; ---------------------------------------------------------------------------

loc_678:				; CODE XREF: DETECT_JOYSTICK_sub_32+27j
    neg cx
    mov si, cx
    xor cx, cx

loc_681:				; CODE XREF: DETECT_JOYSTICK_sub_32+3Bj
    in  al, dx
    jmp short $+2
; ---------------------------------------------------------------------------

loc_680:				; CODE XREF: DETECT_JOYSTICK_sub_32+35j
    and al, bh
    jz  short loc_235
    loop  loc_681
    sti
    stc
    retn
; ---------------------------------------------------------------------------

loc_235:				; CODE XREF: DETECT_JOYSTICK_sub_32+39j
					; DETECT_JOYSTICK_sub_32+48j
    out dx, al
    jmp short $+2
; ---------------------------------------------------------------------------

loc_682:				; CODE XREF: DETECT_JOYSTICK_sub_32+41j
    in  al, dx
    jmp short $+2
; ---------------------------------------------------------------------------

loc_683:				; CODE XREF: DETECT_JOYSTICK_sub_32+44j
    test  al, bl
    jz  short loc_235
    xor cx, cx

loc_686:				; CODE XREF: DETECT_JOYSTICK_sub_32+53j
    in  al, dx
    jmp short $+2
; ---------------------------------------------------------------------------

loc_684:				; CODE XREF: DETECT_JOYSTICK_sub_32+4Dj
    test  al, bh
    jz  short loc_685
    loop  loc_686
    sti
    stc
    retn
; ---------------------------------------------------------------------------

loc_685:				; CODE XREF: DETECT_JOYSTICK_sub_32+51j
    sti
    neg cx
    mov di, cx
    clc
    retn
DETECT_JOYSTICK_sub_32 endp

ENDIF
ENDIF

; =============== S U B R O U T I N E =======================================


set_interrupt_vectors_0x97_and_0x24 proc near ;	CODE XREF: START_GAME_sub_22p
          ; INIT_PART_init_stuff_sub_26+5Ep
    push  cs
    pop ds
		lea	dx, interrupt_0x97
    inc dx
    inc dx
		or	dx, 1		; dx = (offset interrupt_0x97 +	2) | 1;	<== dx = 11B5
					;
					; dx |=	1 means	make it	odd if not already
    mov ax, 2597h ; al = interrupt 0x97
    int 21h   ; DOS - SET INTERRUPT VECTOR
          ; AL = interrupt number
          ; DS:DX = new vector to be used for specified interrupt
    mov al, 24h   ; interrupt 0x24
		mov	dx, offset interrupt_0x24
    int 21h   ; DOS - SET INTERRUPT VECTOR
          ; AL = interrupt number
          ; DS:DX = new vector to be used for specified interrupt
    retn
set_interrupt_vectors_0x97_and_0x24 endp

; ---------------------------------------------------------------------------
dos_country_information db 20h dup(0) ; DATA XREF: INIT_PART_is_currency_franco
          ; INIT_PART_is_currency_franc+Co
          
IFDEF DIRECT_START
  STACK_VALUE = 0BBh
ELSE
  STACK_VALUE = 0
ENDIF          
          
    db 1DEh dup(STACK_VALUE)    ; also stack space !!!
stack_space_end_unk_342 dw 0 ; DATA XREF: start_0+Ao start_0+31o

IFDEF DIRECT_START

IF 1  
  gfx_mode dw 0
  cmd_error db 'you need to select the video card type',0dh,0ah,0dh,0ah
            db 'ae.com 0-4',0dh,0ah
            db '  0=CGA',0dh,0ah
            db '  1=EGA',0dh,0ah
            db '  2=Tandy',0dh,0ah
            db '  3=Hercules',0dh,0ah
            db '  4=VGA',0dh,0ah
            db 0dh,0ah
            db '  example: ae.com 4',0dh,0ah
            db '  for VGA',0dh,0ah,0dh,0ah
            db '$'
            
  error6 db '6','$'
  error8 db '8','$'
  error5 db '5','$'
  error4 db '4','$'
ENDIF  

config_tat_buffer:
IFNDEF CLEANUP
  db 2Ch dup(EMPTY) ; nops
ENDIF  
ELSE

config_tat_buffer dw 302h  ; DATA XREF: read_config_and_resize_memory+12o
          ; read_config_and_resize_memory+31o ...
          ; after the initialization all the routines under this
          ; lable are overwritten by the config.tat loading
          ; these routines are not used anymore so the game re-uses the
          ; space the code occupied !!! dirty !!!!
          ;
					; some of the vars are only used before	overwriting the	buffer
					; so not every var here	is stable
    dw 201h
    dw 103h
INIT_ONLY_word_755 dw 0			; DATA XREF: INIT_PART_sub_259+15r
					; INIT_PART_sub_259+23r
    dw 101h
IN_MAIN_MENU_selected_gfx_index	dw 202h	; DATA XREF: start_0+64r
          ; GFX_SELECT_MENU_sub_9+9Cw ...
          ; used after init for gfx selection
          ;
          ; 0 = CGA
          ; 1 = EGA
          ; 2 = Tandy
          ; 3 = Hercules
          ; 4 = VGA
					;
					; used after read of config.tat	- so at	this point
					; the config.tat data gets overwritten
		dw 0
		dw 303h
		dw 103h
		dw 0
		dw 405h
		dw 505h			; 0x0505 - vga
		dw 0
		dw 304h
		dw 404h
		dw 504h
    
INIT_value_call_offset_table0 db 1	; DATA XREF: INIT_PART_sub_36+27o
		dw offset INIT_PART_sub_259
INIT_value_call_offset_table1 db 0	; DATA XREF: INIT_PART_sub_36+18w
          ; INIT_PART_sub_259+30w
		dw offset INIT_PART_sub_267
INIT_value_call_offset_table2 db 0	; DATA XREF: INIT_PART_sub_36+12w
          ; INIT_PART_sub_259+2Aw ...
		dw offset INIT_PART_sub_276
INIT_value_call_offset_table3 db 0	; DATA XREF: INIT_PART_sub_36+1Ew
          ; INIT_PART_sub_259+36w ...
		dw offset INIT_PART_sub_280    
ENDIF

IFDEF DIRECT_START
  patch2_begin:

; =============== S U B R O U T I N E =======================================

SIMPLE_INIT_routine proc near ; CODE XREF: start_0+1Fp
    push  ds
    
IF 1
    cmp byte ptr ds:[80h],2
    jnz command_line_error
    cmp byte ptr ds:[81h],20h
    jnz command_line_error
    cmp byte ptr ds:[82h],'0'
    jb command_line_error
    cmp byte ptr ds:[82h],'4'
    jg command_line_error
    cmp byte ptr ds:[83h],0dh
    jnz command_line_error
    xor ax,ax
    mov al,ds:[82h]
    sub ax,'0'
    mov cs:gfx_mode,ax
    jmp ok
    
command_line_error:
    mov dx,offset cmd_error
    mov ah,09h
    int 21h    
    
    mov ax,4c00h
    int 21h
    
ENDIF    
    
ok:    
    mov ah, 0Fh
    int 10h   ; - VIDEO - GET CURRENT VIDEO MODE
          ; Return: AH = number of columns on screen
          ; AL = current video mode
          ; BH = current active display page
		mov	cs:saved_video_mode, al
    
    push  es
    xor ax, ax
    mov es, ax    ; https://wiki.osdev.org/Memory_Map_(x86)
          ; https://wiki.osdev.org/Interrupt_Vector_Table
          ;
					; ivt[1].ofs(4)/seg(6)
          ;
          ; interrupt 1 is reserved
    assume es:nothing
		mov	ax, es:4	; interrupt 1 ofs
    mov cs:saved_int1_ptr.ofs, ax
		mov	ax, es:6	; interrupt 1 seg
		mov	cs:saved_int1_ptr.segm,	ax
    pop es
    assume es:nothing
    push  es
    push  ds
    xor ax, ax
		mov	ds, ax		; ds = 0
    assume ds:nothing
    mov ax, cs
    mov es, ax    ; es = cs
    assume es:seg000
    cld
		lea	di, saved_5_interrupt_pointers
		mov	si, 25Ch	; 0x97 * sizeof(ptr16) = 0x25C -> save 5 interrupt far ptrs
					; starting with	interrupt 0x97 (151)
		mov	cx, 20		; sizeof(ptr16)*5
    rep movsb
    pop ds
    assume ds:seg000
    pop es
    assume es:nothing
   
    call  set_interrupt_vectors_0x97_and_0x24
    
    pop ds
    retn
SIMPLE_INIT_routine endp    
  
  patch2_end:
  
IFNDEF CLEANUP  
  ;----
  ; keep all the offsets around intact
  patch2_size = patch2_end - patch2_begin
  patch2_rest_nops = 1DCh - patch2_size
  IF patch2_rest_nops LT 0
    .ERR <patch2 code too big>
  ENDIF
  db patch2_rest_nops dup(EMPTY) ; nops
  ;----
ENDIF  
  
ELSE

INIT_PART_is_tandy_system proc near ; CODE XREF: INIT_PART_init_stuff_sub_26+5Bp
    push  es
    mov ax, 0F000h
    mov es, ax
    assume es:nothing
    xor ax, ax    ; clear bit 7
    mov cl, es:0C000h ; cl = byte ptr [0F000:0C000]
    cmp cl, 21h   ; Check for TANDY if F000h:C000h == 21h
          ; https://www.brutman.com/forums/viewtopic.php?f=6&t=119#p506
					;
					; // https://jeffpar.github.io/kbarchive/kb/061/Q61421/
					; // The computer's ROM BIOS is stored at location F000:0000 through F000:FFFF.
					; // Copyright messages	are commonly stored at locations F000:E000, F000:C000, and
					; // F000:0000.
					;
					; if( *(uint8_t	far*)MK_FP(0xF000,0xC000) == 0x21 )
					; {
					;   word_752[1]	|= 0x40;
					; }
    jnz short loc_687
    mov ax, 40h   ; set bit 7

loc_687:        ; CODE XREF: INIT_PART_is_tandy_system+10j
    pop es
    assume es:nothing
		or	byte ptr cs:word_752+1,	al ; high byte set
    retn
INIT_PART_is_tandy_system endp


; =============== S U B R O U T I N E =======================================


INIT_PART_is_currency_franc proc near ; CODE XREF: INIT_PART_init_stuff_sub_26+26p
    lea dx, dos_country_information
    mov ax, 3800h
    int 21h   ; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
          ; get current-country info
          ; DS:DX -> buffer for returned info
          ;
          ; https://github.com/FDOS/kernel/blob/00daebd468773d54cfc277cb91f70409b6840eb3/kernel/nls.c#L603
          ;
          ;  * and gives a buffer of (at most) 0x20 bytes
          ;  * MSDOS 6.2 copies only 0x18 bytes
          ;  * RBIL documents 0x18 bytes and calls 10 bytes 'reserved'
          ;  * so we change the amount of copied bytes to 0x18
    mov ax, 2000h ; 0b0010000000000000
          ; 14. bit => bit[13] = true
    lea bx, dos_country_information
    cmp byte ptr [bx+2], 'F' ; https://stanislavs.org/helppc/country_codes.html
          ;
          ; 02  5bytes   ASCIIZ currency symbol
          ;
          ; F => Franc
          ; $ => Dollar
    jz  short loc_688
    xor ax, ax

loc_688:        ; CODE XREF: INIT_PART_is_currency_franc+14j
		or	cs:some_feature_flags, ax ; (dos_country_information.currency[0] == 'F') ? 0x2000 : 0;
          ;
          ; if( dos_country_information.currency[0] == 'F' )
          ; {
					;   some_feature_flags |= 0x2000;
          ; }
    retn
INIT_PART_is_currency_franc endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_36 proc near    ; CODE XREF: INIT_PART_init_stuff_sub_26+58p
    push  si
    push  di
    mov ax, cs
    mov ds, ax
		mov	di, offset word_752 ; contains 00 00 00	00 at this point
    mov word ptr [di], 0
    mov word ptr [di+2], 0
		mov	cs:INIT_value_call_offset_table2, 1 ; all 0 at this point, all setted with 1
		mov	cs:INIT_value_call_offset_table1, 1
		mov	cs:INIT_value_call_offset_table3, 1
    mov cx, 4
		mov	si, offset INIT_value_call_offset_table0

the_loop:       ; CODE XREF: INIT_PART_sub_36:loc_690j
    lodsb     ; al = ds:[si] = cs:[19D8h] => al = 1
    test  al, al
    lodsw     ; ax = ds:[si] = cs:[19D8h+1] -> ax = 0x1A5C
		jz	short loc_690	; if( lodsb value == 0 ) goto loc_690
    push  si    ; si = 19DBh
    push  cx    ; cx = 4
    call  ax    ; ax = 1A5C, near call to seg000:1A5C (sub_259) (in ALPHA_E.COM)
					; uses di
    pop cx
    pop si

loc_690:        ; CODE XREF: INIT_PART_sub_36+2Ej
    loop  the_loop
    call  INIT_PART_sub_37
    pop di
    pop si
    retn
INIT_PART_sub_36 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_259 proc near		; DATA XREF: seg000:19D9o
    mov ax, 1A00h
    int 10h   ; - VIDEO - DISPLAY COMBINATION (PS,VGA/MCGA): read display combination code
          ;
					; al=00H= Query	current	display	combination
					;
          ; http://www.techhelpmanual.com/177-int_10h_1ah__set_or_query_display_combination_code.html
					;
					; https://github.com/cirosantilli/ralf-brown-interrupt-list/blob/fde1a5ac1b7e8a45ff4255ee275ee77c7fe7e256/inter61a/INTERRUP.A#L3913
		cmp	al, 1Ah		; is query supported?
		jnz	short early_exit
    mov cx, bx    ; current DCC code in BX
          ;
          ; RBIL\INTERRUP.A
          ; BL = active display code
          ; BH = alternate display code
					;
					;  00h	  no display
					;  01h	  monochrome adapter w/	monochrome display
					;  02h	  CGA w/ color display
					;  03h	  reserved
					;  04h	  EGA w/ color display
					;  05h	  EGA w/ monochrome display
					;  06h	  PGA w/ color display
					;  07h	  VGA w/ monochrome analog display
					;  08h	  VGA w/ color analog display
					;  09h	  reserved
					;  0Ah	  MCGA w/ digital color	display
					;  0Bh	  MCGA w/ monochrome analog display
					;  0Ch	  MCGA w/ color	analog display
					;  FFh	  unknown display type
		xor	bh, bh		; bh = 0 ->  ID	of alternate display code is not used?
    or  ch, ch
		jz	short loc_691	; if(ch==0) - alternate	display	= no display?
    mov bl, ch
    add bx, bx ; *= 2 --> to get the word-table index
		mov	ax, cs:INIT_ONLY_word_755[bx]
    mov [di+2], ax
    mov bl, cl
    xor bh, bh

loc_691:        ; CODE XREF: INIT_PART_sub_259+Fj
    add bx, bx
		mov	ax, cs:INIT_ONLY_word_755[bx]
    mov [di], ax
		mov	cs:INIT_value_call_offset_table2, 0
		mov	cs:INIT_value_call_offset_table1, 0
		mov	cs:INIT_value_call_offset_table3, 0
    lea bx, [di]
    cmp byte ptr [bx], 1
    jz  short loc_692
    lea bx, [di+2]
    cmp byte ptr [bx], 1
		jnz	short early_exit

loc_692:        ; CODE XREF: INIT_PART_sub_259+41j
    mov word ptr [bx], 0
		mov	cs:INIT_value_call_offset_table3, 1

early_exit:				; CODE XREF: INIT_PART_sub_259+7j
          ; INIT_PART_sub_259+49j
    retn
INIT_PART_sub_259 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_267 proc near		; DATA XREF: seg000:19DCo
    mov bl, 10h
    mov ah, 12h
    int 10h   ; - VIDEO - ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA) - GET EGA INFO
          ; Return: BH = 00h color mode in effect CH = feature bits, CL = switch settings
					;
					; ralf-brown-interrupt-list\inter61a\INTERRUP.A	line: 3092
					;
					; (Table 00024)
					; Values for switch settings on	original EGA/VGA:
					;  00h	      primary MDA/HGC,	  secondary EGA+ 40x25
					;  01h-03h    primary MDA/HGC,	  secondary EGA+ 80x25
					;  04h	      primary CGA 40x25,  secondary EGA+ 80x25 mono
					;  05h	      primary CGA 80x25,  secondary EGA+ 80x25 mono
					;  06h	      primary EGA+ 40x25, secondary MDA/HGC (optional)
					;  07h-09h    primary EGA+ 80x25, secondary MDA/HGC (optional)
					;  0Ah	      primary EGA+ 80x25 mono,secondary	CGA 40x25 (optional)
					;  0Bh	      primary EGA+ 80x25 mono,secondary	CGA 80x25 (optional)
		cmp	bl, 10h		; http://www.techhelpmanual.com/168-int_10h_12h_bl_10h__get_ega_information.html
					;
					; If upon return from this call, BL>4,
					; then you must	be running on a	CGA or MDA (not	an EGA or VGA).
		jz	short exit	; not ega/vga
		mov	al, cl		; switch settings? ==> with dosbox: 0x09
		shr	al, 1		; al *=	2 -> get word index
		mov	bx, offset config_tat_buffer
		xlat			; bx = table offset, al	= table[ah]
    mov ah, al
    mov al, 3
    call  INIT_PART_sub_263
    cmp ah, 1
    jz  short loc_693
		mov	cs:INIT_value_call_offset_table2, 0
		jmp	short exit
; ---------------------------------------------------------------------------

loc_693:        ; CODE XREF: INIT_PART_sub_267+1Dj
		mov	cs:INIT_value_call_offset_table3, 0

exit:					; CODE XREF: INIT_PART_sub_267+9j
          ; INIT_PART_sub_267+25j
    retn
INIT_PART_sub_267 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_276 proc near		; DATA XREF: seg000:19DFo
		mov	dx, 3D4h	; rW  CRT (6845) register index	  (CGA/MCGA/color EGA/color VGA)
    call  INIT_PART_sub_269
		jb	short locret_694 ; taken with hercules
		mov	al, 2		; take with cga
    mov ah, 2
    call  INIT_PART_sub_263

locret_694:       ; CODE XREF: INIT_PART_sub_276+6j
    retn
INIT_PART_sub_276 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_280 proc near		; DATA XREF: seg000:19E2o
    mov dx, 3B5h
    in  al, dx    ; Video: CRT controller internal registers
    cmp al, 0FFh
		jz	short locret_695 ; taken with with dosbox machine=cga
		mov	dl, 0BAh	; with machine=hercules
    in  al, dx    ; Video status bits:
          ; 0: retrace.  1=display is in vert or horiz retrace.
          ; 1: 1=light pen is triggered; 0=armed
          ; 2: 1=light pen switch is open; 0=closed
          ; 3: 1=vertical sync pulse is occurring.
		mov	dl, al		; unused !!!
    mov ah, 80h
    mov al, 1
    call  INIT_PART_sub_263

locret_695:       ; CODE XREF: INIT_PART_sub_280+6j
    retn
INIT_PART_sub_280 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_269 proc near   ; CODE XREF: INIT_PART_sub_276+3p
    mov al, 0Fh
    out dx, al
    inc dx
    in  al, dx
    mov ah, al
    mov al, 66h
    out dx, al
    mov cx, 100h

loc_696:        ; CODE XREF: INIT_PART_sub_269:loc_696j
    loop  loc_696
    in  al, dx
IFDEF WASM_BINARY_EQUAL
    db 86h,0E0h
ELSE
    xchg  ah, al
ENDIF    
    out dx, al
    cmp ah, 66h
    jz  short locret_697
    stc

locret_697:       ; CODE XREF: INIT_PART_sub_269+16j
    retn
INIT_PART_sub_269 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_37 proc near    ; CODE XREF: INIT_PART_sub_36+38p
    cmp word ptr [di+2], 0
    jz  short locret_249
    cmp byte ptr [di], 5
    jge short locret_249
    cmp byte ptr [di+2], 5
    jge short locret_249
    mov ah, 0Fh
    int 10h   ; - VIDEO - GET CURRENT VIDEO MODE
          ; Return: AH = number of columns on screen
          ; AL = current video mode
          ; BH = current active display page
    and al, 7
    cmp al, 7
    jz  short loc_698 ; https://stanislavs.org/helppc/int_10-0.html
          ;
          ; jumps on 0x7 or 0xF
          ;
          ; 07  80x25 Monochrome text (MDA,HERC,EGA,VGA)
          ; 0F  640x350 Monochrome graphics (EGA,VGA)
    cmp byte ptr [di+1], 1
    jnz short locret_249
    jmp short loc_699
; ---------------------------------------------------------------------------

loc_698:        ; CODE XREF: INIT_PART_sub_37+19j
    cmp byte ptr [di+1], 1
    jz  short locret_249

loc_699:        ; CODE XREF: INIT_PART_sub_37+21j
    mov ax, [di]
    xchg  ax, [di+2]
    mov [di], ax

locret_249:       ; CODE XREF: INIT_PART_sub_37+4j
          ; INIT_PART_sub_37+9j ...
    retn
INIT_PART_sub_37 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_sub_263 proc near   ; CODE XREF: INIT_PART_sub_267+17p
          ; INIT_PART_sub_276+Cp ...
    lea bx, [di]
    cmp byte ptr [bx], 0
    jz  short loc_700
    lea bx, [di+2]

loc_700:        ; CODE XREF: INIT_PART_sub_263+5j
    mov [bx], ax
    retn
INIT_PART_sub_263 endp


; =============== S U B R O U T I N E =======================================


INIT_PART_init_stuff_sub_26 proc near ; CODE XREF: start_0+1Fp
    push  ds
    mov ah, 0Fh
    int 10h   ; - VIDEO - GET CURRENT VIDEO MODE
          ; Return: AH = number of columns on screen
          ; AL = current video mode
          ; BH = current active display page
		mov	cs:saved_video_mode, al
    push  ds
    mov ax, 40h   ; bios data?
    mov ds, ax
    assume ds:nothing
		mov	si, 0B800h	; color	text seg
    mov ax, ds:63h  ; 40:63   word    Base port address for active 6845 CRT controller
          ;       3B4h = mono, 3D4h = color
    cmp ax, 3D4h
    jz  short loc_716
		mov	si, 0B000h	; mono color text seg

loc_716:        ; CODE XREF: INIT_PART_init_stuff_sub_26+18j
    pop ds
    assume ds:seg000
		mov	cs:text_video_seg, si ;	video base address
    call  init_video_mode_and_cursor
    call  INIT_PART_is_currency_franc
    push  es
    xor ax, ax
    mov es, ax    ; https://wiki.osdev.org/Memory_Map_(x86)
          ; https://wiki.osdev.org/Interrupt_Vector_Table
          ;
					; ivt[1].ofs(4)/seg(6)
          ;
          ; interrupt 1 is reserved
    assume es:nothing
		mov	ax, es:(1*sizeof ptr16+ptr16.ofs)	; interrupt 1 ofs
    mov cs:saved_int1_ptr.ofs, ax
		mov	ax, es:(1*sizeof ptr16+ptr16.segm)	; interrupt 1 seg
		mov	cs:saved_int1_ptr.segm,	ax
    pop es
    assume es:nothing
    push  es
    push  ds
    xor ax, ax
		mov	ds, ax		; ds = 0
    assume ds:nothing
    mov ax, cs
    mov es, ax    ; es = cs
    assume es:seg000
    cld
		lea	di, saved_5_interrupt_pointers
		mov	si, 97h*sizeof ptr16 ; Interrupt[97h]
		mov	cx, 5*sizeof ptr16 ;  5 interrupts
    rep movsb
    pop ds
    assume ds:seg000
    pop es
    assume es:nothing
    call  INIT_PART_sub_36
    call  INIT_PART_is_tandy_system
    call  set_interrupt_vectors_0x97_and_0x24
    pop ds
    retn
INIT_PART_init_stuff_sub_26 endp

ENDIF

seg000    ends


    end start
